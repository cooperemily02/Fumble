{"ast":null,"code":"'use strict';\n\nconst MongoError = require('../core/error').MongoError;\n\nconst Aspect = require('./operation').Aspect;\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst ReadPreference = require('../core/topologies/read_preference');\n\nconst isRetryableError = require('../core/error').isRetryableError;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst isUnifiedTopology = require('../core/utils').isUnifiedTopology;\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {Operation} operation The operation to execute\n * @param {function} callback The command result callback\n */\n\n\nfunction executeOperation(topology, operation, callback) {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!(operation instanceof OperationBase)) {\n    throw new TypeError('This method requires a valid operation instance');\n  }\n\n  if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {\n    return selectServerForSessionSupport(topology, operation, callback);\n  }\n\n  const Promise = topology.s.promiseLibrary; // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n  let session, owner;\n\n  if (topology.hasSessionSupport()) {\n    if (operation.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      operation.session = session;\n    } else if (operation.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  function executeCallback(err, result) {\n    if (session && session.owner === owner) {\n      session.endSession();\n\n      if (operation.session === session) {\n        operation.clearSession();\n      }\n    }\n\n    callback(err, result);\n  }\n\n  try {\n    if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {\n      executeWithServerSelection(topology, operation, executeCallback);\n    } else {\n      operation.execute(executeCallback);\n    }\n  } catch (e) {\n    if (session && session.owner === owner) {\n      session.endSession();\n\n      if (operation.session === session) {\n        operation.clearSession();\n      }\n    }\n\n    throw e;\n  }\n\n  return result;\n}\n\nfunction supportsRetryableReads(server) {\n  return maxWireVersion(server) >= 6;\n}\n\nfunction executeWithServerSelection(topology, operation, callback) {\n  const readPreference = operation.readPreference || ReadPreference.primary;\n  const inTransaction = operation.session && operation.session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  }\n\n  const serverSelectionOptions = {\n    readPreference,\n    session: operation.session\n  };\n\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(null, result);\n    }\n\n    if (!isRetryableError(err)) {\n      return callback(err);\n    } // select a new server, and attempt to retry the operation\n\n\n    topology.selectServer(serverSelectionOptions, (err, server) => {\n      if (err || !supportsRetryableReads(server)) {\n        callback(err, null);\n        return;\n      }\n\n      operation.execute(server, callback);\n    });\n  } // select a server, and execute the operation against it\n\n\n  topology.selectServer(serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;\n\n    if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {\n      operation.execute(server, callbackWithRetry);\n      return;\n    }\n\n    operation.execute(server, callback);\n  });\n} // TODO: This is only supported for unified topology, it should go away once\n//       we remove support for legacy topology types.\n\n\nfunction selectServerForSessionSupport(topology, operation, callback) {\n  const Promise = topology.s.promiseLibrary;\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, result) => {\n        if (err) return reject(err);\n        resolve(result);\n      };\n    });\n  }\n\n  topology.selectServer(ReadPreference.primaryPreferred, err => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    executeOperation(topology, operation, callback);\n  });\n  return result;\n}\n\nmodule.exports = executeOperation;","map":null,"metadata":{},"sourceType":"script"}