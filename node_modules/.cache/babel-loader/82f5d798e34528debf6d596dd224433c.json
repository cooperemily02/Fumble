{"ast":null,"code":"'use strict';\n\nvar retrieveBSON = require('./utils').retrieveBSON;\n\nvar BSON = retrieveBSON();\nvar Long = BSON.Long;\n\nconst Buffer = require('safe-buffer').Buffer; // Incrementing request id\n\n\nvar _requestId = 0; // Wire command operation ids\n\nvar opcodes = require('../wireprotocol/shared').opcodes; // Query flags\n\n\nvar OPTS_TAILABLE_CURSOR = 2;\nvar OPTS_SLAVE = 4;\nvar OPTS_OPLOG_REPLAY = 8;\nvar OPTS_NO_CURSOR_TIMEOUT = 16;\nvar OPTS_AWAIT_DATA = 32;\nvar OPTS_EXHAUST = 64;\nvar OPTS_PARTIAL = 128; // Response flags\n\nvar CURSOR_NOT_FOUND = 1;\nvar QUERY_FAILURE = 2;\nvar SHARD_CONFIG_STALE = 4;\nvar AWAIT_CAPABLE = 8;\n/**************************************************************\n * QUERY\n **************************************************************/\n\nvar Query = function (bson, ns, query, options) {\n  var self = this; // Basic options needed to be passed in\n\n  if (ns == null) throw new Error('ns must be specified for query');\n  if (query == null) throw new Error('query must be specified for query'); // Validate that we are not passing 0x00 in the collection name\n\n  if (ns.indexOf('\\x00') !== -1) {\n    throw new Error('namespace cannot contain a null character');\n  } // Basic options\n\n\n  this.bson = bson;\n  this.ns = ns;\n  this.query = query; // Additional options\n\n  this.numberToSkip = options.numberToSkip || 0;\n  this.numberToReturn = options.numberToReturn || 0;\n  this.returnFieldSelector = options.returnFieldSelector || null;\n  this.requestId = Query.getRequestId(); // special case for pre-3.2 find commands, delete ASAP\n\n  this.pre32Limit = options.pre32Limit; // Serialization option\n\n  this.serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n  this.ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;\n  this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;\n  this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : true;\n  this.batchSize = self.numberToReturn; // Flags\n\n  this.tailable = false;\n  this.slaveOk = typeof options.slaveOk === 'boolean' ? options.slaveOk : false;\n  this.oplogReplay = false;\n  this.noCursorTimeout = false;\n  this.awaitData = false;\n  this.exhaust = false;\n  this.partial = false;\n}; //\n// Assign a new request Id\n\n\nQuery.prototype.incRequestId = function () {\n  this.requestId = _requestId++;\n}; //\n// Assign a new request Id\n\n\nQuery.nextRequestId = function () {\n  return _requestId + 1;\n}; //\n// Uses a single allocated buffer for the process, avoiding multiple memory allocations\n\n\nQuery.prototype.toBin = function () {\n  var self = this;\n  var buffers = [];\n  var projection = null; // Set up the flags\n\n  var flags = 0;\n\n  if (this.tailable) {\n    flags |= OPTS_TAILABLE_CURSOR;\n  }\n\n  if (this.slaveOk) {\n    flags |= OPTS_SLAVE;\n  }\n\n  if (this.oplogReplay) {\n    flags |= OPTS_OPLOG_REPLAY;\n  }\n\n  if (this.noCursorTimeout) {\n    flags |= OPTS_NO_CURSOR_TIMEOUT;\n  }\n\n  if (this.awaitData) {\n    flags |= OPTS_AWAIT_DATA;\n  }\n\n  if (this.exhaust) {\n    flags |= OPTS_EXHAUST;\n  }\n\n  if (this.partial) {\n    flags |= OPTS_PARTIAL;\n  } // If batchSize is different to self.numberToReturn\n\n\n  if (self.batchSize !== self.numberToReturn) self.numberToReturn = self.batchSize; // Allocate write protocol header buffer\n\n  var header = Buffer.alloc(4 * 4 + // Header\n  4 + // Flags\n  Buffer.byteLength(self.ns) + 1 + // namespace\n  4 + // numberToSkip\n  4 // numberToReturn\n  ); // Add header to buffers\n\n  buffers.push(header); // Serialize the query\n\n  var query = self.bson.serialize(this.query, {\n    checkKeys: this.checkKeys,\n    serializeFunctions: this.serializeFunctions,\n    ignoreUndefined: this.ignoreUndefined\n  }); // Add query document\n\n  buffers.push(query);\n\n  if (self.returnFieldSelector && Object.keys(self.returnFieldSelector).length > 0) {\n    // Serialize the projection document\n    projection = self.bson.serialize(this.returnFieldSelector, {\n      checkKeys: this.checkKeys,\n      serializeFunctions: this.serializeFunctions,\n      ignoreUndefined: this.ignoreUndefined\n    }); // Add projection document\n\n    buffers.push(projection);\n  } // Total message size\n\n\n  var totalLength = header.length + query.length + (projection ? projection.length : 0); // Set up the index\n\n  var index = 4; // Write total document length\n\n  header[3] = totalLength >> 24 & 0xff;\n  header[2] = totalLength >> 16 & 0xff;\n  header[1] = totalLength >> 8 & 0xff;\n  header[0] = totalLength & 0xff; // Write header information requestId\n\n  header[index + 3] = this.requestId >> 24 & 0xff;\n  header[index + 2] = this.requestId >> 16 & 0xff;\n  header[index + 1] = this.requestId >> 8 & 0xff;\n  header[index] = this.requestId & 0xff;\n  index = index + 4; // Write header information responseTo\n\n  header[index + 3] = 0 >> 24 & 0xff;\n  header[index + 2] = 0 >> 16 & 0xff;\n  header[index + 1] = 0 >> 8 & 0xff;\n  header[index] = 0 & 0xff;\n  index = index + 4; // Write header information OP_QUERY\n\n  header[index + 3] = opcodes.OP_QUERY >> 24 & 0xff;\n  header[index + 2] = opcodes.OP_QUERY >> 16 & 0xff;\n  header[index + 1] = opcodes.OP_QUERY >> 8 & 0xff;\n  header[index] = opcodes.OP_QUERY & 0xff;\n  index = index + 4; // Write header information flags\n\n  header[index + 3] = flags >> 24 & 0xff;\n  header[index + 2] = flags >> 16 & 0xff;\n  header[index + 1] = flags >> 8 & 0xff;\n  header[index] = flags & 0xff;\n  index = index + 4; // Write collection name\n\n  index = index + header.write(this.ns, index, 'utf8') + 1;\n  header[index - 1] = 0; // Write header information flags numberToSkip\n\n  header[index + 3] = this.numberToSkip >> 24 & 0xff;\n  header[index + 2] = this.numberToSkip >> 16 & 0xff;\n  header[index + 1] = this.numberToSkip >> 8 & 0xff;\n  header[index] = this.numberToSkip & 0xff;\n  index = index + 4; // Write header information flags numberToReturn\n\n  header[index + 3] = this.numberToReturn >> 24 & 0xff;\n  header[index + 2] = this.numberToReturn >> 16 & 0xff;\n  header[index + 1] = this.numberToReturn >> 8 & 0xff;\n  header[index] = this.numberToReturn & 0xff;\n  index = index + 4; // Return the buffers\n\n  return buffers;\n};\n\nQuery.getRequestId = function () {\n  return ++_requestId;\n};\n/**************************************************************\n * GETMORE\n **************************************************************/\n\n\nvar GetMore = function (bson, ns, cursorId, opts) {\n  opts = opts || {};\n  this.numberToReturn = opts.numberToReturn || 0;\n  this.requestId = _requestId++;\n  this.bson = bson;\n  this.ns = ns;\n  this.cursorId = cursorId;\n}; //\n// Uses a single allocated buffer for the process, avoiding multiple memory allocations\n\n\nGetMore.prototype.toBin = function () {\n  var length = 4 + Buffer.byteLength(this.ns) + 1 + 4 + 8 + 4 * 4; // Create command buffer\n\n  var index = 0; // Allocate buffer\n\n  var _buffer = Buffer.alloc(length); // Write header information\n  // index = write32bit(index, _buffer, length);\n\n\n  _buffer[index + 3] = length >> 24 & 0xff;\n  _buffer[index + 2] = length >> 16 & 0xff;\n  _buffer[index + 1] = length >> 8 & 0xff;\n  _buffer[index] = length & 0xff;\n  index = index + 4; // index = write32bit(index, _buffer, requestId);\n\n  _buffer[index + 3] = this.requestId >> 24 & 0xff;\n  _buffer[index + 2] = this.requestId >> 16 & 0xff;\n  _buffer[index + 1] = this.requestId >> 8 & 0xff;\n  _buffer[index] = this.requestId & 0xff;\n  index = index + 4; // index = write32bit(index, _buffer, 0);\n\n  _buffer[index + 3] = 0 >> 24 & 0xff;\n  _buffer[index + 2] = 0 >> 16 & 0xff;\n  _buffer[index + 1] = 0 >> 8 & 0xff;\n  _buffer[index] = 0 & 0xff;\n  index = index + 4; // index = write32bit(index, _buffer, OP_GETMORE);\n\n  _buffer[index + 3] = opcodes.OP_GETMORE >> 24 & 0xff;\n  _buffer[index + 2] = opcodes.OP_GETMORE >> 16 & 0xff;\n  _buffer[index + 1] = opcodes.OP_GETMORE >> 8 & 0xff;\n  _buffer[index] = opcodes.OP_GETMORE & 0xff;\n  index = index + 4; // index = write32bit(index, _buffer, 0);\n\n  _buffer[index + 3] = 0 >> 24 & 0xff;\n  _buffer[index + 2] = 0 >> 16 & 0xff;\n  _buffer[index + 1] = 0 >> 8 & 0xff;\n  _buffer[index] = 0 & 0xff;\n  index = index + 4; // Write collection name\n\n  index = index + _buffer.write(this.ns, index, 'utf8') + 1;\n  _buffer[index - 1] = 0; // Write batch size\n  // index = write32bit(index, _buffer, numberToReturn);\n\n  _buffer[index + 3] = this.numberToReturn >> 24 & 0xff;\n  _buffer[index + 2] = this.numberToReturn >> 16 & 0xff;\n  _buffer[index + 1] = this.numberToReturn >> 8 & 0xff;\n  _buffer[index] = this.numberToReturn & 0xff;\n  index = index + 4; // Write cursor id\n  // index = write32bit(index, _buffer, cursorId.getLowBits());\n\n  _buffer[index + 3] = this.cursorId.getLowBits() >> 24 & 0xff;\n  _buffer[index + 2] = this.cursorId.getLowBits() >> 16 & 0xff;\n  _buffer[index + 1] = this.cursorId.getLowBits() >> 8 & 0xff;\n  _buffer[index] = this.cursorId.getLowBits() & 0xff;\n  index = index + 4; // index = write32bit(index, _buffer, cursorId.getHighBits());\n\n  _buffer[index + 3] = this.cursorId.getHighBits() >> 24 & 0xff;\n  _buffer[index + 2] = this.cursorId.getHighBits() >> 16 & 0xff;\n  _buffer[index + 1] = this.cursorId.getHighBits() >> 8 & 0xff;\n  _buffer[index] = this.cursorId.getHighBits() & 0xff;\n  index = index + 4; // Return buffer\n\n  return _buffer;\n};\n/**************************************************************\n * KILLCURSOR\n **************************************************************/\n\n\nvar KillCursor = function (bson, ns, cursorIds) {\n  this.ns = ns;\n  this.requestId = _requestId++;\n  this.cursorIds = cursorIds;\n}; //\n// Uses a single allocated buffer for the process, avoiding multiple memory allocations\n\n\nKillCursor.prototype.toBin = function () {\n  var length = 4 + 4 + 4 * 4 + this.cursorIds.length * 8; // Create command buffer\n\n  var index = 0;\n\n  var _buffer = Buffer.alloc(length); // Write header information\n  // index = write32bit(index, _buffer, length);\n\n\n  _buffer[index + 3] = length >> 24 & 0xff;\n  _buffer[index + 2] = length >> 16 & 0xff;\n  _buffer[index + 1] = length >> 8 & 0xff;\n  _buffer[index] = length & 0xff;\n  index = index + 4; // index = write32bit(index, _buffer, requestId);\n\n  _buffer[index + 3] = this.requestId >> 24 & 0xff;\n  _buffer[index + 2] = this.requestId >> 16 & 0xff;\n  _buffer[index + 1] = this.requestId >> 8 & 0xff;\n  _buffer[index] = this.requestId & 0xff;\n  index = index + 4; // index = write32bit(index, _buffer, 0);\n\n  _buffer[index + 3] = 0 >> 24 & 0xff;\n  _buffer[index + 2] = 0 >> 16 & 0xff;\n  _buffer[index + 1] = 0 >> 8 & 0xff;\n  _buffer[index] = 0 & 0xff;\n  index = index + 4; // index = write32bit(index, _buffer, OP_KILL_CURSORS);\n\n  _buffer[index + 3] = opcodes.OP_KILL_CURSORS >> 24 & 0xff;\n  _buffer[index + 2] = opcodes.OP_KILL_CURSORS >> 16 & 0xff;\n  _buffer[index + 1] = opcodes.OP_KILL_CURSORS >> 8 & 0xff;\n  _buffer[index] = opcodes.OP_KILL_CURSORS & 0xff;\n  index = index + 4; // index = write32bit(index, _buffer, 0);\n\n  _buffer[index + 3] = 0 >> 24 & 0xff;\n  _buffer[index + 2] = 0 >> 16 & 0xff;\n  _buffer[index + 1] = 0 >> 8 & 0xff;\n  _buffer[index] = 0 & 0xff;\n  index = index + 4; // Write batch size\n  // index = write32bit(index, _buffer, this.cursorIds.length);\n\n  _buffer[index + 3] = this.cursorIds.length >> 24 & 0xff;\n  _buffer[index + 2] = this.cursorIds.length >> 16 & 0xff;\n  _buffer[index + 1] = this.cursorIds.length >> 8 & 0xff;\n  _buffer[index] = this.cursorIds.length & 0xff;\n  index = index + 4; // Write all the cursor ids into the array\n\n  for (var i = 0; i < this.cursorIds.length; i++) {\n    // Write cursor id\n    // index = write32bit(index, _buffer, cursorIds[i].getLowBits());\n    _buffer[index + 3] = this.cursorIds[i].getLowBits() >> 24 & 0xff;\n    _buffer[index + 2] = this.cursorIds[i].getLowBits() >> 16 & 0xff;\n    _buffer[index + 1] = this.cursorIds[i].getLowBits() >> 8 & 0xff;\n    _buffer[index] = this.cursorIds[i].getLowBits() & 0xff;\n    index = index + 4; // index = write32bit(index, _buffer, cursorIds[i].getHighBits());\n\n    _buffer[index + 3] = this.cursorIds[i].getHighBits() >> 24 & 0xff;\n    _buffer[index + 2] = this.cursorIds[i].getHighBits() >> 16 & 0xff;\n    _buffer[index + 1] = this.cursorIds[i].getHighBits() >> 8 & 0xff;\n    _buffer[index] = this.cursorIds[i].getHighBits() & 0xff;\n    index = index + 4;\n  } // Return buffer\n\n\n  return _buffer;\n};\n\nvar Response = function (bson, message, msgHeader, msgBody, opts) {\n  opts = opts || {\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false\n  };\n  this.parsed = false;\n  this.raw = message;\n  this.data = msgBody;\n  this.bson = bson;\n  this.opts = opts; // Read the message header\n\n  this.length = msgHeader.length;\n  this.requestId = msgHeader.requestId;\n  this.responseTo = msgHeader.responseTo;\n  this.opCode = msgHeader.opCode;\n  this.fromCompressed = msgHeader.fromCompressed; // Read the message body\n\n  this.responseFlags = msgBody.readInt32LE(0);\n  this.cursorId = new Long(msgBody.readInt32LE(4), msgBody.readInt32LE(8));\n  this.startingFrom = msgBody.readInt32LE(12);\n  this.numberReturned = msgBody.readInt32LE(16); // Preallocate document array\n\n  this.documents = new Array(this.numberReturned); // Flag values\n\n  this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;\n  this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;\n  this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;\n  this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;\n  this.promoteLongs = typeof opts.promoteLongs === 'boolean' ? opts.promoteLongs : true;\n  this.promoteValues = typeof opts.promoteValues === 'boolean' ? opts.promoteValues : true;\n  this.promoteBuffers = typeof opts.promoteBuffers === 'boolean' ? opts.promoteBuffers : false;\n};\n\nResponse.prototype.isParsed = function () {\n  return this.parsed;\n};\n\nResponse.prototype.parse = function (options) {\n  // Don't parse again if not needed\n  if (this.parsed) return;\n  options = options || {}; // Allow the return of raw documents instead of parsing\n\n  var raw = options.raw || false;\n  var documentsReturnedIn = options.documentsReturnedIn || null;\n  var promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : this.opts.promoteLongs;\n  var promoteValues = typeof options.promoteValues === 'boolean' ? options.promoteValues : this.opts.promoteValues;\n  var promoteBuffers = typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : this.opts.promoteBuffers;\n\n  var bsonSize, _options; // Set up the options\n\n\n  _options = {\n    promoteLongs: promoteLongs,\n    promoteValues: promoteValues,\n    promoteBuffers: promoteBuffers\n  }; // Position within OP_REPLY at which documents start\n  // (See https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#wire-op-reply)\n\n  this.index = 20; //\n  // Parse Body\n  //\n\n  for (var i = 0; i < this.numberReturned; i++) {\n    bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24; // If we have raw results specified slice the return document\n\n    if (raw) {\n      this.documents[i] = this.data.slice(this.index, this.index + bsonSize);\n    } else {\n      this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);\n    } // Adjust the index\n\n\n    this.index = this.index + bsonSize;\n  }\n\n  if (this.documents.length === 1 && documentsReturnedIn != null && raw) {\n    const fieldsAsRaw = {};\n    fieldsAsRaw[documentsReturnedIn] = true;\n    _options.fieldsAsRaw = fieldsAsRaw;\n    const doc = this.bson.deserialize(this.documents[0], _options);\n    this.documents = [doc];\n  } // Set parsed\n\n\n  this.parsed = true;\n};\n\nmodule.exports = {\n  Query: Query,\n  GetMore: GetMore,\n  Response: Response,\n  KillCursor: KillCursor\n};","map":null,"metadata":{},"sourceType":"script"}