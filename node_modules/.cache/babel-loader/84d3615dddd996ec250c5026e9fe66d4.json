{"ast":null,"code":"'use strict';\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst decorateWithCollation = require('../utils').decorateWithCollation;\n\nconst executeCommand = require('./db_ops').executeCommand;\n\nconst formattedOrderClause = require('../utils').formattedOrderClause;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst MongoError = require('../error').MongoError;\n\nclass FindAndModifyOperation extends OperationBase {\n  constructor(collection, query, sort, doc, options) {\n    super(options);\n    this.collection = collection;\n    this.query = query;\n    this.sort = sort;\n    this.doc = doc;\n  }\n\n  execute(callback) {\n    const coll = this.collection;\n    const query = this.query;\n    const sort = formattedOrderClause(this.sort);\n    const doc = this.doc;\n    let options = this.options; // Create findAndModify command object\n\n    const queryObject = {\n      findAndModify: coll.collectionName,\n      query: query\n    };\n\n    if (sort) {\n      queryObject.sort = sort;\n    }\n\n    queryObject.new = options.new ? true : false;\n    queryObject.remove = options.remove ? true : false;\n    queryObject.upsert = options.upsert ? true : false;\n    const projection = options.projection || options.fields;\n\n    if (projection) {\n      queryObject.fields = projection;\n    }\n\n    if (options.arrayFilters) {\n      queryObject.arrayFilters = options.arrayFilters;\n    }\n\n    if (doc && !options.remove) {\n      queryObject.update = doc;\n    }\n\n    if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS; // Either use override on the function, or go back to default on either the collection\n    // level or db\n\n    options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // No check on the documents\n\n    options.checkKeys = false; // Final options for retryable writes and write concern\n\n    options = applyRetryableWrites(options, coll.s.db);\n    options = applyWriteConcern(options, {\n      db: coll.s.db,\n      collection: coll\n    }, options); // Decorate the findAndModify command with the write Concern\n\n    if (options.writeConcern) {\n      queryObject.writeConcern = options.writeConcern;\n    } // Have we specified bypassDocumentValidation\n\n\n    if (options.bypassDocumentValidation === true) {\n      queryObject.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    options.readPreference = ReadPreference.primary; // Have we specified collation\n\n    try {\n      decorateWithCollation(queryObject, coll, options);\n    } catch (err) {\n      return callback(err, null);\n    }\n\n    if (options.hint) {\n      // TODO: once this method becomes a CommandOperationV2 we will have the server\n      // in place to check.\n      const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;\n\n      if (unacknowledgedWrite || maxWireVersion(coll.s.topology) < 8) {\n        callback(new MongoError('The current topology does not support a hint on findAndModify commands'));\n        return;\n      }\n\n      queryObject.hint = options.hint;\n    } // Execute the command\n\n\n    executeCommand(coll.s.db, queryObject, options, (err, result) => {\n      if (err) return handleCallback(callback, err, null);\n      return handleCallback(callback, null, result);\n    });\n  }\n\n}\n\nmodule.exports = FindAndModifyOperation;","map":null,"metadata":{},"sourceType":"script"}