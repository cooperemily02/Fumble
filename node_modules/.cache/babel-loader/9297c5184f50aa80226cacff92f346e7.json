{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits,\n    f = require('util').format,\n    diff = require('./shared').diff,\n    EventEmitter = require('events').EventEmitter,\n    Logger = require('../connection/logger'),\n    ReadPreference = require('./read_preference'),\n    MongoError = require('../error').MongoError,\n    Buffer = require('safe-buffer').Buffer;\n\nvar TopologyType = {\n  Single: 'Single',\n  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',\n  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',\n  Sharded: 'Sharded',\n  Unknown: 'Unknown'\n};\nvar ServerType = {\n  Standalone: 'Standalone',\n  Mongos: 'Mongos',\n  PossiblePrimary: 'PossiblePrimary',\n  RSPrimary: 'RSPrimary',\n  RSSecondary: 'RSSecondary',\n  RSArbiter: 'RSArbiter',\n  RSOther: 'RSOther',\n  RSGhost: 'RSGhost',\n  Unknown: 'Unknown'\n};\n\nvar ReplSetState = function (options) {\n  options = options || {}; // Add event listener\n\n  EventEmitter.call(this); // Topology state\n\n  this.topologyType = TopologyType.ReplicaSetNoPrimary;\n  this.setName = options.setName; // Server set\n\n  this.set = {}; // Unpacked options\n\n  this.id = options.id;\n  this.setName = options.setName; // Replicaset logger\n\n  this.logger = options.logger || Logger('ReplSet', options); // Server selection index\n\n  this.index = 0; // Acceptable latency\n\n  this.acceptableLatency = options.acceptableLatency || 15; // heartbeatFrequencyMS\n\n  this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000; // Server side\n\n  this.primary = null;\n  this.secondaries = [];\n  this.arbiters = [];\n  this.passives = [];\n  this.ghosts = []; // Current unknown hosts\n\n  this.unknownServers = []; // In set status\n\n  this.set = {}; // Status\n\n  this.maxElectionId = null;\n  this.maxSetVersion = 0; // Description of the Replicaset\n\n  this.replicasetDescription = {\n    topologyType: 'Unknown',\n    servers: []\n  };\n  this.logicalSessionTimeoutMinutes = undefined;\n};\n\ninherits(ReplSetState, EventEmitter);\n\nReplSetState.prototype.hasPrimaryAndSecondary = function () {\n  return this.primary != null && this.secondaries.length > 0;\n};\n\nReplSetState.prototype.hasPrimaryOrSecondary = function () {\n  return this.hasPrimary() || this.hasSecondary();\n};\n\nReplSetState.prototype.hasPrimary = function () {\n  return this.primary != null;\n};\n\nReplSetState.prototype.hasSecondary = function () {\n  return this.secondaries.length > 0;\n};\n\nReplSetState.prototype.get = function (host) {\n  var servers = this.allServers();\n\n  for (var i = 0; i < servers.length; i++) {\n    if (servers[i].name.toLowerCase() === host.toLowerCase()) {\n      return servers[i];\n    }\n  }\n\n  return null;\n};\n\nReplSetState.prototype.allServers = function (options) {\n  options = options || {};\n  var servers = this.primary ? [this.primary] : [];\n  servers = servers.concat(this.secondaries);\n  if (!options.ignoreArbiters) servers = servers.concat(this.arbiters);\n  servers = servers.concat(this.passives);\n  return servers;\n};\n\nReplSetState.prototype.destroy = function (options, callback) {\n  const serversToDestroy = this.secondaries.concat(this.arbiters).concat(this.passives).concat(this.ghosts);\n  if (this.primary) serversToDestroy.push(this.primary);\n  let serverCount = serversToDestroy.length;\n\n  const serverDestroyed = () => {\n    serverCount--;\n\n    if (serverCount > 0) {\n      return;\n    } // Clear out the complete state\n\n\n    this.secondaries = [];\n    this.arbiters = [];\n    this.passives = [];\n    this.ghosts = [];\n    this.unknownServers = [];\n    this.set = {};\n    this.primary = null; // Emit the topology changed\n\n    emitTopologyDescriptionChanged(this);\n\n    if (typeof callback === 'function') {\n      callback(null, null);\n    }\n  };\n\n  if (serverCount === 0) {\n    serverDestroyed();\n    return;\n  }\n\n  serversToDestroy.forEach(server => server.destroy(options, serverDestroyed));\n};\n\nReplSetState.prototype.remove = function (server, options) {\n  options = options || {}; // Get the server name and lowerCase it\n\n  var serverName = server.name.toLowerCase(); // Only remove if the current server is not connected\n\n  var servers = this.primary ? [this.primary] : [];\n  servers = servers.concat(this.secondaries);\n  servers = servers.concat(this.arbiters);\n  servers = servers.concat(this.passives); // Check if it's active and this is just a failed connection attempt\n\n  for (var i = 0; i < servers.length; i++) {\n    if (!options.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {\n      return;\n    }\n  } // If we have it in the set remove it\n\n\n  if (this.set[serverName]) {\n    this.set[serverName].type = ServerType.Unknown;\n    this.set[serverName].electionId = null;\n    this.set[serverName].setName = null;\n    this.set[serverName].setVersion = null;\n  } // Remove type\n\n\n  var removeType = null; // Remove from any lists\n\n  if (this.primary && this.primary.equals(server)) {\n    this.primary = null;\n    this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    removeType = 'primary';\n  } // Remove from any other server lists\n\n\n  removeType = removeFrom(server, this.secondaries) ? 'secondary' : removeType;\n  removeType = removeFrom(server, this.arbiters) ? 'arbiter' : removeType;\n  removeType = removeFrom(server, this.passives) ? 'secondary' : removeType;\n  removeFrom(server, this.ghosts);\n  removeFrom(server, this.unknownServers); // Push to unknownServers\n\n  this.unknownServers.push(serverName); // Do we have a removeType\n\n  if (removeType) {\n    this.emit('left', removeType, server);\n  }\n};\n\nconst isArbiter = ismaster => ismaster.arbiterOnly && ismaster.setName;\n\nReplSetState.prototype.update = function (server) {\n  var self = this; // Get the current ismaster\n\n  var ismaster = server.lastIsMaster(); // Get the server name and lowerCase it\n\n  var serverName = server.name.toLowerCase(); //\n  // Add any hosts\n  //\n\n  if (ismaster) {\n    // Join all the possible new hosts\n    var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];\n    hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);\n    hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);\n    hosts = hosts.map(function (s) {\n      return s.toLowerCase();\n    }); // Add all hosts as unknownServers\n\n    for (var i = 0; i < hosts.length; i++) {\n      // Add to the list of unknown server\n      if (this.unknownServers.indexOf(hosts[i]) === -1 && (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)) {\n        this.unknownServers.push(hosts[i].toLowerCase());\n      }\n\n      if (!this.set[hosts[i]]) {\n        this.set[hosts[i]] = {\n          type: ServerType.Unknown,\n          electionId: null,\n          setName: null,\n          setVersion: null\n        };\n      }\n    }\n  } //\n  // Unknown server\n  //\n\n\n  if (!ismaster && !inList(ismaster, server, this.unknownServers)) {\n    self.set[serverName] = {\n      type: ServerType.Unknown,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    }; // Update set information about the server instance\n\n    self.set[serverName].type = ServerType.Unknown;\n    self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;\n    self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;\n    self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;\n\n    if (self.unknownServers.indexOf(server.name) === -1) {\n      self.unknownServers.push(serverName);\n    } // Set the topology\n\n\n    return false;\n  } // Update logicalSessionTimeoutMinutes\n\n\n  if (ismaster.logicalSessionTimeoutMinutes !== undefined && !isArbiter(ismaster)) {\n    if (self.logicalSessionTimeoutMinutes === undefined || ismaster.logicalSessionTimeoutMinutes === null) {\n      self.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;\n    } else {\n      self.logicalSessionTimeoutMinutes = Math.min(self.logicalSessionTimeoutMinutes, ismaster.logicalSessionTimeoutMinutes);\n    }\n  } //\n  // Is this a mongos\n  //\n\n\n  if (ismaster && ismaster.msg === 'isdbgrid') {\n    if (this.primary && this.primary.name === serverName) {\n      this.primary = null;\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n\n    return false;\n  } // A RSGhost instance\n\n\n  if (ismaster.isreplicaset) {\n    self.set[serverName] = {\n      type: ServerType.RSGhost,\n      setVersion: null,\n      electionId: null,\n      setName: ismaster.setName\n    };\n\n    if (this.primary && this.primary.name === serverName) {\n      this.primary = null;\n    } // Set the topology\n\n\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName; // Set the topology\n\n    return false;\n  } // A RSOther instance\n\n\n  if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {\n    self.set[serverName] = {\n      type: ServerType.RSOther,\n      setVersion: null,\n      electionId: null,\n      setName: ismaster.setName\n    }; // Set the topology\n\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    return false;\n  } //\n  // Standalone server, destroy and return\n  //\n\n\n  if (ismaster && ismaster.ismaster && !ismaster.setName) {\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;\n    this.remove(server, {\n      force: true\n    });\n    return false;\n  } //\n  // Server in maintanance mode\n  //\n\n\n  if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {\n    this.remove(server, {\n      force: true\n    });\n    return false;\n  } //\n  // If the .me field does not match the passed in server\n  //\n\n\n  if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {\n    if (this.logger.isWarn()) {\n      this.logger.warn(f('the seedlist server was removed due to its address %s not matching its ismaster.me address %s', server.name, ismaster.me));\n    } // Delete from the set\n\n\n    delete this.set[serverName]; // Delete unknown servers\n\n    removeFrom(server, self.unknownServers); // Destroy the instance\n\n    server.destroy({\n      force: true\n    }); // Set the type of topology we have\n\n    if (this.primary && !this.primary.equals(server)) {\n      this.topologyType = TopologyType.ReplicaSetWithPrimary;\n    } else {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    } //\n    // We have a potential primary\n    //\n\n\n    if (!this.primary && ismaster.primary) {\n      this.set[ismaster.primary.toLowerCase()] = {\n        type: ServerType.PossiblePrimary,\n        setName: null,\n        electionId: null,\n        setVersion: null\n      };\n    }\n\n    return false;\n  } //\n  // Primary handling\n  //\n\n\n  if (!this.primary && ismaster.ismaster && ismaster.setName) {\n    var ismasterElectionId = server.lastIsMaster().electionId;\n\n    if (this.setName && this.setName !== ismaster.setName) {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n      return new MongoError(f('setName from ismaster does not match provided connection setName [%s] != [%s]', ismaster.setName, this.setName));\n    }\n\n    if (!this.maxElectionId && ismasterElectionId) {\n      this.maxElectionId = ismasterElectionId;\n    } else if (this.maxElectionId && ismasterElectionId) {\n      var result = compareObjectIds(this.maxElectionId, ismasterElectionId); // Get the electionIds\n\n      var ismasterSetVersion = server.lastIsMaster().setVersion;\n\n      if (result === 1) {\n        this.topologyType = TopologyType.ReplicaSetNoPrimary;\n        return false;\n      } else if (result === 0 && ismasterSetVersion) {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          this.topologyType = TopologyType.ReplicaSetNoPrimary;\n          return false;\n        }\n      }\n\n      this.maxSetVersion = ismasterSetVersion;\n      this.maxElectionId = ismasterElectionId;\n    } // Hande normalization of server names\n\n\n    var normalizedHosts = ismaster.hosts.map(function (x) {\n      return x.toLowerCase();\n    });\n    var locationIndex = normalizedHosts.indexOf(serverName); // Validate that the server exists in the host list\n\n    if (locationIndex !== -1) {\n      self.primary = server;\n      self.set[serverName] = {\n        type: ServerType.RSPrimary,\n        setVersion: ismaster.setVersion,\n        electionId: ismaster.electionId,\n        setName: ismaster.setName\n      }; // Set the topology\n\n      this.topologyType = TopologyType.ReplicaSetWithPrimary;\n      if (ismaster.setName) this.setName = ismaster.setName;\n      removeFrom(server, self.unknownServers);\n      removeFrom(server, self.secondaries);\n      removeFrom(server, self.passives);\n      self.emit('joined', 'primary', server);\n    } else {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } else if (ismaster.ismaster && ismaster.setName) {\n    // Get the electionIds\n    var currentElectionId = self.set[self.primary.name.toLowerCase()].electionId;\n    var currentSetVersion = self.set[self.primary.name.toLowerCase()].setVersion;\n    var currentSetName = self.set[self.primary.name.toLowerCase()].setName;\n    ismasterElectionId = server.lastIsMaster().electionId;\n    ismasterSetVersion = server.lastIsMaster().setVersion;\n    var ismasterSetName = server.lastIsMaster().setName; // Is it the same server instance\n\n    if (this.primary.equals(server) && currentSetName === ismasterSetName) {\n      return false;\n    } // If we do not have the same rs name\n\n\n    if (currentSetName && currentSetName !== ismasterSetName) {\n      if (!this.primary.equals(server)) {\n        this.topologyType = TopologyType.ReplicaSetWithPrimary;\n      } else {\n        this.topologyType = TopologyType.ReplicaSetNoPrimary;\n      }\n\n      return false;\n    } // Check if we need to replace the server\n\n\n    if (currentElectionId && ismasterElectionId) {\n      result = compareObjectIds(currentElectionId, ismasterElectionId);\n\n      if (result === 1) {\n        return false;\n      } else if (result === 0 && currentSetVersion > ismasterSetVersion) {\n        return false;\n      }\n    } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {\n      if (ismasterSetVersion < this.maxSetVersion) {\n        return false;\n      }\n    }\n\n    if (!this.maxElectionId && ismasterElectionId) {\n      this.maxElectionId = ismasterElectionId;\n    } else if (this.maxElectionId && ismasterElectionId) {\n      result = compareObjectIds(this.maxElectionId, ismasterElectionId);\n\n      if (result === 1) {\n        return false;\n      } else if (result === 0 && currentSetVersion && ismasterSetVersion) {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          return false;\n        }\n      } else {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          return false;\n        }\n      }\n\n      this.maxElectionId = ismasterElectionId;\n      this.maxSetVersion = ismasterSetVersion;\n    } else {\n      this.maxSetVersion = ismasterSetVersion;\n    } // Modify the entry to unknown\n\n\n    self.set[self.primary.name.toLowerCase()] = {\n      type: ServerType.Unknown,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    }; // Signal primary left\n\n    self.emit('left', 'primary', this.primary); // Destroy the instance\n\n    self.primary.destroy({\n      force: true\n    }); // Set the new instance\n\n    self.primary = server; // Set the set information\n\n    self.set[serverName] = {\n      type: ServerType.RSPrimary,\n      setVersion: ismaster.setVersion,\n      electionId: ismaster.electionId,\n      setName: ismaster.setName\n    }; // Set the topology\n\n    this.topologyType = TopologyType.ReplicaSetWithPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n    removeFrom(server, self.secondaries);\n    removeFrom(server, self.passives);\n    self.emit('joined', 'primary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } // A possible instance\n\n\n  if (!this.primary && ismaster.primary) {\n    self.set[ismaster.primary.toLowerCase()] = {\n      type: ServerType.PossiblePrimary,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    };\n  } //\n  // Secondary handling\n  //\n\n\n  if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName === ismaster.setName) {\n    addToList(self, ServerType.RSSecondary, ismaster, server, this.secondaries); // Set the topology\n\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers); // Remove primary\n\n    if (this.primary && this.primary.name.toLowerCase() === serverName) {\n      server.destroy({\n        force: true\n      });\n      this.primary = null;\n      self.emit('left', 'primary', server);\n    } // Emit secondary joined replicaset\n\n\n    self.emit('joined', 'secondary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } //\n  // Arbiter handling\n  //\n\n\n  if (isArbiter(ismaster) && !inList(ismaster, server, this.arbiters) && this.setName && this.setName === ismaster.setName) {\n    addToList(self, ServerType.RSArbiter, ismaster, server, this.arbiters); // Set the topology\n\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n    self.emit('joined', 'arbiter', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } //\n  // Passive handling\n  //\n\n\n  if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName === ismaster.setName) {\n    addToList(self, ServerType.RSSecondary, ismaster, server, this.passives); // Set the topology\n\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers); // Remove primary\n\n    if (this.primary && this.primary.name.toLowerCase() === serverName) {\n      server.destroy({\n        force: true\n      });\n      this.primary = null;\n      self.emit('left', 'primary', server);\n    }\n\n    self.emit('joined', 'secondary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } //\n  // Remove the primary\n  //\n\n\n  if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {\n    self.emit('left', 'primary', this.primary);\n    this.primary.destroy({\n      force: true\n    });\n    this.primary = null;\n    this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    return false;\n  }\n\n  this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n  return false;\n};\n/**\n * Recalculate single server max staleness\n * @method\n */\n\n\nReplSetState.prototype.updateServerMaxStaleness = function (server, haInterval) {\n  // Locate the max secondary lastwrite\n  var max = 0; // Go over all secondaries\n\n  for (var i = 0; i < this.secondaries.length; i++) {\n    max = Math.max(max, this.secondaries[i].lastWriteDate);\n  } // Perform this servers staleness calculation\n\n\n  if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {\n    server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;\n  } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {\n    server.staleness = max - server.lastWriteDate + haInterval;\n  }\n};\n/**\n * Recalculate all the staleness values for secodaries\n * @method\n */\n\n\nReplSetState.prototype.updateSecondariesMaxStaleness = function (haInterval) {\n  for (var i = 0; i < this.secondaries.length; i++) {\n    this.updateServerMaxStaleness(this.secondaries[i], haInterval);\n  }\n};\n/**\n * Pick a server by the passed in ReadPreference\n * @method\n * @param {ReadPreference} readPreference The ReadPreference instance to use\n */\n\n\nReplSetState.prototype.pickServer = function (readPreference) {\n  // If no read Preference set to primary by default\n  readPreference = readPreference || ReadPreference.primary; // maxStalenessSeconds is not allowed with a primary read\n\n  if (readPreference.preference === 'primary' && readPreference.maxStalenessSeconds != null) {\n    return new MongoError('primary readPreference incompatible with maxStalenessSeconds');\n  } // Check if we have any non compatible servers for maxStalenessSeconds\n\n\n  var allservers = this.primary ? [this.primary] : [];\n  allservers = allservers.concat(this.secondaries); // Does any of the servers not support the right wire protocol version\n  // for maxStalenessSeconds when maxStalenessSeconds specified on readPreference. Then error out\n\n  if (readPreference.maxStalenessSeconds != null) {\n    for (var i = 0; i < allservers.length; i++) {\n      if (allservers[i].ismaster.maxWireVersion < 5) {\n        return new MongoError('maxStalenessSeconds not supported by at least one of the replicaset members');\n      }\n    }\n  } // Do we have the nearest readPreference\n\n\n  if (readPreference.preference === 'nearest' && readPreference.maxStalenessSeconds == null) {\n    return pickNearest(this, readPreference);\n  } else if (readPreference.preference === 'nearest' && readPreference.maxStalenessSeconds != null) {\n    return pickNearestMaxStalenessSeconds(this, readPreference);\n  } // Get all the secondaries\n\n\n  var secondaries = this.secondaries; // Check if we can satisfy and of the basic read Preferences\n\n  if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {\n    return new MongoError('no secondary server available');\n  }\n\n  if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length === 0 && this.primary == null) {\n    return new MongoError('no secondary or primary server available');\n  }\n\n  if (readPreference.equals(ReadPreference.primary) && this.primary == null) {\n    return new MongoError('no primary server available');\n  } // Secondary preferred or just secondaries\n\n\n  if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {\n    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {\n      // Pick nearest of any other servers available\n      var server = pickNearest(this, readPreference); // No server in the window return primary\n\n      if (server) {\n        return server;\n      }\n    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {\n      // Pick nearest of any other servers available\n      server = pickNearestMaxStalenessSeconds(this, readPreference); // No server in the window return primary\n\n      if (server) {\n        return server;\n      }\n    }\n\n    if (readPreference.equals(ReadPreference.secondaryPreferred)) {\n      return this.primary;\n    }\n\n    return null;\n  } // Primary preferred\n\n\n  if (readPreference.equals(ReadPreference.primaryPreferred)) {\n    server = null; // We prefer the primary if it's available\n\n    if (this.primary) {\n      return this.primary;\n    } // Pick a secondary\n\n\n    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {\n      server = pickNearest(this, readPreference);\n    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {\n      server = pickNearestMaxStalenessSeconds(this, readPreference);\n    } //  Did we find a server\n\n\n    if (server) return server;\n  } // Return the primary\n\n\n  return this.primary;\n}; //\n// Filter serves by tags\n\n\nvar filterByTags = function (readPreference, servers) {\n  if (readPreference.tags == null) return servers;\n  var filteredServers = [];\n  var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags]; // Iterate over the tags\n\n  for (var j = 0; j < tagsArray.length; j++) {\n    var tags = tagsArray[j]; // Iterate over all the servers\n\n    for (var i = 0; i < servers.length; i++) {\n      var serverTag = servers[i].lastIsMaster().tags || {}; // Did we find the a matching server\n\n      var found = true; // Check if the server is valid\n\n      for (var name in tags) {\n        if (serverTag[name] !== tags[name]) {\n          found = false;\n        }\n      } // Add to candidate list\n\n\n      if (found) {\n        filteredServers.push(servers[i]);\n      }\n    }\n  } // Returned filtered servers\n\n\n  return filteredServers;\n};\n\nfunction pickNearestMaxStalenessSeconds(self, readPreference) {\n  // Only get primary and secondaries as seeds\n  var servers = []; // Get the maxStalenessMS\n\n  var maxStalenessMS = readPreference.maxStalenessSeconds * 1000; // Check if the maxStalenessMS > 90 seconds\n\n  if (maxStalenessMS < 90 * 1000) {\n    return new MongoError('maxStalenessSeconds must be set to at least 90 seconds');\n  } // Add primary to list if not a secondary read preference\n\n\n  if (self.primary && readPreference.preference !== 'secondary' && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  } // Add all the secondaries\n\n\n  for (var i = 0; i < self.secondaries.length; i++) {\n    servers.push(self.secondaries[i]);\n  } // If we have a secondaryPreferred readPreference and no server add the primary\n\n\n  if (self.primary && servers.length === 0 && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  } // Filter by tags\n\n\n  servers = filterByTags(readPreference, servers); // Filter by latency\n\n  servers = servers.filter(function (s) {\n    return s.staleness <= maxStalenessMS;\n  }); // Sort by time\n\n  servers.sort(function (a, b) {\n    return a.lastIsMasterMS - b.lastIsMasterMS;\n  }); // No servers, default to primary\n\n  if (servers.length === 0) {\n    return null;\n  } // Ensure index does not overflow the number of available servers\n\n\n  self.index = self.index % servers.length; // Get the server\n\n  var server = servers[self.index]; // Add to the index\n\n  self.index = self.index + 1; // Return the first server of the sorted and filtered list\n\n  return server;\n}\n\nfunction pickNearest(self, readPreference) {\n  // Only get primary and secondaries as seeds\n  var servers = []; // Add primary to list if not a secondary read preference\n\n  if (self.primary && readPreference.preference !== 'secondary' && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  } // Add all the secondaries\n\n\n  for (var i = 0; i < self.secondaries.length; i++) {\n    servers.push(self.secondaries[i]);\n  } // If we have a secondaryPreferred readPreference and no server add the primary\n\n\n  if (servers.length === 0 && self.primary && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  } // Filter by tags\n\n\n  servers = filterByTags(readPreference, servers); // Sort by time\n\n  servers.sort(function (a, b) {\n    return a.lastIsMasterMS - b.lastIsMasterMS;\n  }); // Locate lowest time (picked servers are lowest time + acceptable Latency margin)\n\n  var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0; // Filter by latency\n\n  servers = servers.filter(function (s) {\n    return s.lastIsMasterMS <= lowest + self.acceptableLatency;\n  }); // No servers, default to primary\n\n  if (servers.length === 0) {\n    return null;\n  } // Ensure index does not overflow the number of available servers\n\n\n  self.index = self.index % servers.length; // Get the server\n\n  var server = servers[self.index]; // Add to the index\n\n  self.index = self.index + 1; // Return the first server of the sorted and filtered list\n\n  return server;\n}\n\nfunction inList(ismaster, server, list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase()) return true;\n  }\n\n  return false;\n}\n\nfunction addToList(self, type, ismaster, server, list) {\n  var serverName = server.name.toLowerCase(); // Update set information about the server instance\n\n  self.set[serverName].type = type;\n  self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;\n  self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;\n  self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster; // Add to the list\n\n  list.push(server);\n}\n\nfunction compareObjectIds(id1, id2) {\n  var a = Buffer.from(id1.toHexString(), 'hex');\n  var b = Buffer.from(id2.toHexString(), 'hex');\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (typeof Buffer.compare === 'function') {\n    return Buffer.compare(a, b);\n  }\n\n  var x = a.length;\n  var y = b.length;\n  var len = Math.min(x, y);\n\n  for (var i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      break;\n    }\n  }\n\n  if (i !== len) {\n    x = a[i];\n    y = b[i];\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0;\n}\n\nfunction removeFrom(server, list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].equals && list[i].equals(server)) {\n      list.splice(i, 1);\n      return true;\n    } else if (typeof list[i] === 'string' && list[i].toLowerCase() === server.name.toLowerCase()) {\n      list.splice(i, 1);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction emitTopologyDescriptionChanged(self) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    var topology = 'Unknown';\n    var setName = self.setName;\n\n    if (self.hasPrimaryAndSecondary()) {\n      topology = 'ReplicaSetWithPrimary';\n    } else if (!self.hasPrimary() && self.hasSecondary()) {\n      topology = 'ReplicaSetNoPrimary';\n    } // Generate description\n\n\n    var description = {\n      topologyType: topology,\n      setName: setName,\n      servers: []\n    }; // Add the primary to the list\n\n    if (self.hasPrimary()) {\n      var desc = self.primary.getDescription();\n      desc.type = 'RSPrimary';\n      description.servers.push(desc);\n    } // Add all the secondaries\n\n\n    description.servers = description.servers.concat(self.secondaries.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'RSSecondary';\n      return description;\n    })); // Add all the arbiters\n\n    description.servers = description.servers.concat(self.arbiters.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'RSArbiter';\n      return description;\n    })); // Add all the passives\n\n    description.servers = description.servers.concat(self.passives.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'RSSecondary';\n      return description;\n    })); // Get the diff\n\n    var diffResult = diff(self.replicasetDescription, description); // Create the result\n\n    var result = {\n      topologyId: self.id,\n      previousDescription: self.replicasetDescription,\n      newDescription: description,\n      diff: diffResult\n    }; // Emit the topologyDescription change\n    // if(diffResult.servers.length > 0) {\n\n    self.emit('topologyDescriptionChanged', result); // }\n    // Set the new description\n\n    self.replicasetDescription = description;\n  }\n}\n\nmodule.exports = ReplSetState;","map":null,"metadata":{},"sourceType":"script"}