{"ast":null,"code":"'use strict';\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst MongoError = require('../core').MongoError;\n\nconst OperationBase = require('./operation').OperationBase;\n\nclass BulkWriteOperation extends OperationBase {\n  constructor(collection, operations, options) {\n    super(options);\n    this.collection = collection;\n    this.operations = operations;\n  }\n\n  execute(callback) {\n    const coll = this.collection;\n    const operations = this.operations;\n    let options = this.options; // Add ignoreUndfined\n\n    if (coll.s.options.ignoreUndefined) {\n      options = Object.assign({}, options);\n      options.ignoreUndefined = coll.s.options.ignoreUndefined;\n    } // Create the bulk operation\n\n\n    const bulk = options.ordered === true || options.ordered == null ? coll.initializeOrderedBulkOp(options) : coll.initializeUnorderedBulkOp(options); // Do we have a collation\n\n    let collation = false; // for each op go through and add to the bulk\n\n    try {\n      for (let i = 0; i < operations.length; i++) {\n        // Get the operation type\n        const key = Object.keys(operations[i])[0]; // Check if we have a collation\n\n        if (operations[i][key].collation) {\n          collation = true;\n        } // Pass to the raw bulk\n\n\n        bulk.raw(operations[i]);\n      }\n    } catch (err) {\n      return callback(err, null);\n    } // Final options for retryable writes and write concern\n\n\n    let finalOptions = Object.assign({}, options);\n    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n    finalOptions = applyWriteConcern(finalOptions, {\n      db: coll.s.db,\n      collection: coll\n    }, options);\n    const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};\n    const capabilities = coll.s.topology.capabilities(); // Did the user pass in a collation, check if our write server supports it\n\n    if (collation && capabilities && !capabilities.commandsTakeCollation) {\n      return callback(new MongoError('server/primary/mongos does not support collation'));\n    } // Execute the bulk\n\n\n    bulk.execute(writeCon, finalOptions, (err, r) => {\n      // We have connection level error\n      if (!r && err) {\n        return callback(err, null);\n      }\n\n      r.insertedCount = r.nInserted;\n      r.matchedCount = r.nMatched;\n      r.modifiedCount = r.nModified || 0;\n      r.deletedCount = r.nRemoved;\n      r.upsertedCount = r.getUpsertedIds().length;\n      r.upsertedIds = {};\n      r.insertedIds = {}; // Update the n\n\n      r.n = r.insertedCount; // Inserted documents\n\n      const inserted = r.getInsertedIds(); // Map inserted ids\n\n      for (let i = 0; i < inserted.length; i++) {\n        r.insertedIds[inserted[i].index] = inserted[i]._id;\n      } // Upserted documents\n\n\n      const upserted = r.getUpsertedIds(); // Map upserted ids\n\n      for (let i = 0; i < upserted.length; i++) {\n        r.upsertedIds[upserted[i].index] = upserted[i]._id;\n      } // Return the results\n\n\n      callback(null, r);\n    });\n  }\n\n}\n\nmodule.exports = BulkWriteOperation;","map":null,"metadata":{},"sourceType":"script"}