{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.complex = exports.color = exports.hsla = exports.hex = exports.rgba = exports.rgbUnit = exports.scale = exports.px = exports.percent = exports.degrees = exports.alpha = exports.number = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n * Value types\n *\n * alpha\n * degrees\n * hex\n * hsla\n * percent\n * px\n * rgbUnit\n * rgb\n * scale\n */\n\n\nvar _transformers = require('./transformers');\n\nvar _parsers = require('./parsers');\n\nvar _utils = require('./utils');\n\nvar number = exports.number = {\n  test: _utils.isNum,\n  parse: parseFloat\n}; // Value types\n\nvar alpha = exports.alpha = _extends({}, number, {\n  transform: _transformers.alpha\n});\n\nvar degrees = exports.degrees = (0, _utils.createUnitType)('deg', _transformers.degrees);\nvar percent = exports.percent = (0, _utils.createUnitType)('%', _transformers.percent);\nvar px = exports.px = (0, _utils.createUnitType)('px', _transformers.px);\n\nvar scale = exports.scale = _extends({}, number, {\n  default: 1\n});\n\nvar rgbUnit = exports.rgbUnit = _extends({}, number, {\n  transform: _transformers.rgbUnit\n});\n\nvar rgba = exports.rgba = {\n  test: _utils.isRgb,\n  parse: _parsers.rgba,\n  transform: _transformers.rgba\n};\n\nvar hex = exports.hex = _extends({}, rgba, {\n  test: _utils.isHex,\n  parse: _parsers.hex\n});\n\nvar hsla = exports.hsla = {\n  test: _utils.isHsl,\n  parse: _parsers.hsla,\n  transform: _transformers.hsla\n};\nvar color = exports.color = {\n  parse: _parsers.color,\n  test: _utils.isColor,\n  transform: _transformers.color\n};\nvar FLOAT_REGEX = /(-)?(\\d[\\d\\.]*)/g;\n\nvar generateToken = function generateToken(token) {\n  return '${' + token + '}';\n};\n\nvar complex = exports.complex = {\n  test: function test(v) {\n    var matches = v.match && v.match(FLOAT_REGEX);\n    return (0, _utils.isArray)(matches) && matches.length > 1;\n  },\n  parse: function parse(v) {\n    var parsedValue = {};\n    v.match(FLOAT_REGEX).forEach(function (value, i) {\n      return parsedValue[i] = parseFloat(value);\n    });\n    return parsedValue;\n  },\n  createTransformer: function createTransformer(prop) {\n    var counter = 0;\n    var template = prop.replace(FLOAT_REGEX, function () {\n      return generateToken(counter++);\n    });\n    return function (v) {\n      var output = template;\n\n      for (var key in v) {\n        if (v.hasOwnProperty(key)) {\n          output = output.replace(generateToken(key), v[key]);\n        }\n      }\n\n      return output;\n    };\n  }\n};","map":{"version":3,"sources":["../../src/inc/value-types.js"],"names":["number","test","parse","parseFloat","transform","degrees","percent","px","default","rgba","hsla","color","FLOAT_REGEX","generateToken","complex","matches","v","parsedValue","createTransformer","counter","template","output"],"mappings":"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","sourcesContent":["/**\n * Value types\n *\n * alpha\n * degrees\n * hex\n * hsla\n * percent\n * px\n * rgbUnit\n * rgb\n * scale\n */\nimport {\n  rgbUnit as transformRGBUnit,\n  rgba as transformRgba,\n  alpha as transformAlpha,\n  hsla as transformHsla,\n  color as transformColor,\n  px as transformPx,\n  percent as transformPercent,\n  degrees as transformDegrees\n} from './transformers';\nimport {\n  hex as parseHex,\n  rgba as parseRgba,\n  hsla as parseHsla,\n  color as parseColor\n} from './parsers';\nimport {\n  createUnitType,\n  isArray,\n  isNum,\n  isRgb,\n  isHsl,\n  isHex,\n  isColor\n} from './utils';\n\nexport const number = {\n  test: isNum,\n  parse: parseFloat\n};\n\n// Value types\nexport const alpha = {\n  ...number,\n  transform: transformAlpha\n};\n\nexport const degrees = createUnitType('deg', transformDegrees);\nexport const percent = createUnitType('%', transformPercent);\nexport const px = createUnitType('px', transformPx);\n\nexport const scale = {\n  ...number,\n  default: 1\n};\n\nexport const rgbUnit = {\n  ...number,\n  transform: transformRGBUnit\n};\n\nexport const rgba = {\n  test: isRgb,\n  parse: parseRgba,\n  transform: transformRgba\n};\n\nexport const hex = {\n  ...rgba,\n  test: isHex,\n  parse: parseHex\n};\n\nexport const hsla = {\n  test: isHsl,\n  parse: parseHsla,\n  transform: transformHsla\n};\n\nexport const color = {\n  parse: parseColor,\n  test: isColor,\n  transform: transformColor\n};\n\nconst FLOAT_REGEX = /(-)?(\\d[\\d\\.]*)/g;\nconst generateToken = (token) => '${' + token + '}';\nexport const complex = {\n  test: (v) => {\n    const matches = v.match && v.match(FLOAT_REGEX);\n    return (isArray(matches) && matches.length > 1);\n  },\n  parse: (v) => {\n    const parsedValue = {};\n    v.match(FLOAT_REGEX).forEach((value, i) => parsedValue[i] = parseFloat(value));\n    return parsedValue;\n  },\n  createTransformer: (prop) => {\n    let counter = 0;\n    const template = prop.replace(FLOAT_REGEX, () => generateToken(counter++));\n\n    return (v) => {\n      let output = template;\n      for (let key in v) {\n        if (v.hasOwnProperty(key)) {\n          output = output.replace(generateToken(key), v[key]);\n        }\n      }\n\n      return output;\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"script"}