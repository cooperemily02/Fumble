{"ast":null,"code":"var path = require('path'),\n    fs = require('fs'),\n    f = require('util').format,\n    resolveFrom = require('resolve-from'),\n    semver = require('semver');\n\nvar exists = fs.existsSync || path.existsSync; // Find the location of a package.json file near or above the given location\n\nvar find_package_json = function (location) {\n  var found = false;\n\n  while (!found) {\n    if (exists(location + '/package.json')) {\n      found = location;\n    } else if (location !== '/') {\n      location = path.dirname(location);\n    } else {\n      return false;\n    }\n  }\n\n  return location;\n}; // Find the package.json object of the module closest up the module call tree that contains name in that module's peerOptionalDependencies\n\n\nvar find_package_json_with_name = function (name) {\n  // Walk up the module call tree until we find a module containing name in its peerOptionalDependencies\n  var currentModule = module;\n  var found = false;\n\n  while (currentModule) {\n    // Check currentModule has a package.json\n    location = currentModule.filename;\n    var location = find_package_json(location);\n\n    if (!location) {\n      currentModule = currentModule.parent;\n      continue;\n    } // Read the package.json file\n\n\n    var object = JSON.parse(fs.readFileSync(f('%s/package.json', location))); // Is the name defined by interal file references\n\n    var parts = name.split(/\\//); // Check whether this package.json contains peerOptionalDependencies containing the name we're searching for\n\n    if (!object.peerOptionalDependencies || object.peerOptionalDependencies && !object.peerOptionalDependencies[parts[0]]) {\n      currentModule = currentModule.parent;\n      continue;\n    }\n\n    found = true;\n    break;\n  } // Check whether name has been found in currentModule's peerOptionalDependencies\n\n\n  if (!found) {\n    throw new Error(f('no optional dependency [%s] defined in peerOptionalDependencies in any package.json', parts[0]));\n  }\n\n  return {\n    object: object,\n    parts: parts\n  };\n};\n\nvar require_optional = function (name, options) {\n  options = options || {};\n  options.strict = typeof options.strict == 'boolean' ? options.strict : true;\n  var res = find_package_json_with_name(name);\n  var object = res.object;\n  var parts = res.parts; // Unpack the expected version\n\n  var expectedVersions = object.peerOptionalDependencies[parts[0]]; // The resolved package\n\n  var moduleEntry = undefined; // Module file\n\n  var moduleEntryFile = name;\n\n  try {\n    // Validate if it's possible to read the module\n    moduleEntry = require(moduleEntryFile);\n  } catch (err) {\n    // Attempt to resolve in top level package\n    try {\n      // Get the module entry file\n      moduleEntryFile = resolveFrom(process.cwd(), name);\n      if (moduleEntryFile == null) return undefined; // Attempt to resolve the module\n\n      moduleEntry = require(moduleEntryFile);\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') return undefined;\n    }\n  } // Resolve the location of the module's package.json file\n\n\n  var location = find_package_json(require.resolve(moduleEntryFile));\n\n  if (!location) {\n    throw new Error('package.json can not be located');\n  } // Read the module file\n\n\n  var dependentOnModule = JSON.parse(fs.readFileSync(f('%s/package.json', location))); // Get the version\n\n  var version = dependentOnModule.version; // Validate if the found module satisfies the version id\n\n  if (semver.satisfies(version, expectedVersions) == false && options.strict) {\n    var error = new Error(f('optional dependency [%s] found but version [%s] did not satisfy constraint [%s]', parts[0], version, expectedVersions));\n    error.code = 'OPTIONAL_MODULE_NOT_FOUND';\n    throw error;\n  } // Satifies the module requirement\n\n\n  return moduleEntry;\n};\n\nrequire_optional.exists = function (name) {\n  try {\n    var m = require_optional(name);\n    if (m === undefined) return false;\n    return true;\n  } catch (err) {\n    return false;\n  }\n};\n\nmodule.exports = require_optional;","map":null,"metadata":{},"sourceType":"script"}