{"ast":null,"code":"'use strict';\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst decorateWithCollation = require('../utils').decorateWithCollation;\n\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\n\nconst executeCommand = require('./db_ops').executeCommand;\n\nconst formattedOrderClause = require('../utils').formattedOrderClause;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('../core').MongoError;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst toError = require('../utils').toError;\n\nconst CursorState = require('../core/cursor').CursorState;\n/**\n * Build the count command.\n *\n * @method\n * @param {collectionOrCursor} an instance of a collection or cursor\n * @param {object} query The query for the count.\n * @param {object} [options] Optional settings. See Collection.prototype.count and Cursor.prototype.count for a list of options.\n */\n\n\nfunction buildCountCommand(collectionOrCursor, query, options) {\n  const skip = options.skip;\n  const limit = options.limit;\n  let hint = options.hint;\n  const maxTimeMS = options.maxTimeMS;\n  query = query || {}; // Final query\n\n  const cmd = {\n    count: options.collectionName,\n    query: query\n  };\n\n  if (collectionOrCursor.s.numberOfRetries) {\n    // collectionOrCursor is a cursor\n    if (collectionOrCursor.options.hint) {\n      hint = collectionOrCursor.options.hint;\n    } else if (collectionOrCursor.cmd.hint) {\n      hint = collectionOrCursor.cmd.hint;\n    }\n\n    decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);\n  } else {\n    decorateWithCollation(cmd, collectionOrCursor, options);\n  } // Add limit, skip and maxTimeMS if defined\n\n\n  if (typeof skip === 'number') cmd.skip = skip;\n  if (typeof limit === 'number') cmd.limit = limit;\n  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;\n  if (hint) cmd.hint = hint; // Do we have a readConcern specified\n\n  decorateWithReadConcern(cmd, collectionOrCursor);\n  return cmd;\n}\n\nfunction deleteCallback(err, r, callback) {\n  if (callback == null) return;\n  if (err && callback) return callback(err);\n  if (r == null) return callback(null, {\n    result: {\n      ok: 1\n    }\n  });\n  r.deletedCount = r.result.n;\n  if (callback) callback(null, r);\n}\n/**\n * Find and update a document.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} doc The fields/vals to be updated.\n * @param {object} [options] Optional settings. See Collection.prototype.findAndModify for a list of options.\n * @param {Collection~findAndModifyCallback} [callback] The command result callback\n * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead\n */\n\n\nfunction findAndModify(coll, query, sort, doc, options, callback) {\n  // Create findAndModify command object\n  const queryObject = {\n    findAndModify: coll.collectionName,\n    query: query\n  };\n  sort = formattedOrderClause(sort);\n\n  if (sort) {\n    queryObject.sort = sort;\n  }\n\n  queryObject.new = options.new ? true : false;\n  queryObject.remove = options.remove ? true : false;\n  queryObject.upsert = options.upsert ? true : false;\n  const projection = options.projection || options.fields;\n\n  if (projection) {\n    queryObject.fields = projection;\n  }\n\n  if (options.arrayFilters) {\n    queryObject.arrayFilters = options.arrayFilters;\n    delete options.arrayFilters;\n  }\n\n  if (doc && !options.remove) {\n    queryObject.update = doc;\n  }\n\n  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS; // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // No check on the documents\n\n  options.checkKeys = false; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Decorate the findAndModify command with the write Concern\n\n  if (finalOptions.writeConcern) {\n    queryObject.writeConcern = finalOptions.writeConcern;\n  } // Have we specified bypassDocumentValidation\n\n\n  if (finalOptions.bypassDocumentValidation === true) {\n    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;\n  }\n\n  finalOptions.readPreference = ReadPreference.primary; // Have we specified collation\n\n  try {\n    decorateWithCollation(queryObject, coll, finalOptions);\n  } catch (err) {\n    return callback(err, null);\n  } // Execute the command\n\n\n  executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    return handleCallback(callback, null, result);\n  });\n}\n/**\n * Retrieves this collections index info.\n *\n * @method\n * @param {Db} db The Db instance on which to retrieve the index info.\n * @param {string} name The name of the collection.\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexInformation(db, name, options, callback) {\n  // If we specified full information\n  const full = options['full'] == null ? false : options['full']; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Process all the results from the index command and collection\n\n  function processResults(indexes) {\n    // Contains all the information\n    let info = {}; // Process all the indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i]; // Let's unpack the object\n\n      info[index.name] = [];\n\n      for (let name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  } // Get the list of indexes of the specified collection\n\n\n  db.collection(name).listIndexes(options).toArray((err, indexes) => {\n    if (err) return callback(toError(err));\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\n    if (full) return handleCallback(callback, null, indexes);\n    handleCallback(callback, null, processResults(indexes));\n  });\n}\n\nfunction prepareDocs(coll, docs, options) {\n  const forceServerObjectId = typeof options.forceServerObjectId === 'boolean' ? options.forceServerObjectId : coll.s.db.options.forceServerObjectId; // no need to modify the docs if server sets the ObjectId\n\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n\n  return docs.map(doc => {\n    if (forceServerObjectId !== true && doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  });\n} // Get the next available document from the cursor, returns null if no more documents are available.\n\n\nfunction nextObject(cursor, callback) {\n  if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {\n    return handleCallback(callback, MongoError.create({\n      message: 'Cursor is closed',\n      driver: true\n    }));\n  }\n\n  if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {\n    try {\n      cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);\n    } catch (err) {\n      return handleCallback(callback, err);\n    }\n  } // Get the next object\n\n\n  cursor._next((err, doc) => {\n    cursor.s.state = CursorState.OPEN;\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, doc);\n  });\n}\n\nfunction insertDocuments(coll, docs, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Ensure we are operating on an array op docs\n\n  docs = Array.isArray(docs) ? docs : [docs]; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // If keep going set unordered\n\n  if (finalOptions.keepGoing === true) finalOptions.ordered = false;\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n  docs = prepareDocs(coll, docs, options); // File inserts\n\n  coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Add docs to the list\n\n    result.ops = docs; // Return the results\n\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction removeDocuments(coll, selector, options, callback) {\n  if (typeof options === 'function') {\n    callback = options, options = {};\n  } else if (typeof selector === 'function') {\n    callback = selector;\n    options = {};\n    selector = {};\n  } // Create an empty options object if the provided one is null\n\n\n  options = options || {}; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // If selector is null set empty\n\n  if (selector == null) selector = {}; // Build the op\n\n  const op = {\n    q: selector,\n    limit: 0\n  };\n\n  if (options.single) {\n    op.limit = 1;\n  } else if (finalOptions.retryWrites) {\n    finalOptions.retryWrites = false;\n  }\n\n  if (options.hint) {\n    op.hint = options.hint;\n  } // Have we specified collation\n\n\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  } // Execute the remove\n\n\n  coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n\n    if (result.result.writeErrors) {\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\n    } // Return the results\n\n\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction updateDocuments(coll, selector, document, options, callback) {\n  if ('function' === typeof options) callback = options, options = null;\n  if (options == null) options = {};\n  if (!('function' === typeof callback)) callback = null; // If we are not providing a selector or document throw\n\n  if (selector == null || typeof selector !== 'object') return callback(toError('selector must be a valid JavaScript object'));\n  if (document == null || typeof document !== 'object') return callback(toError('document must be a valid JavaScript object')); // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Do we return the actual result document\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // Execute the operation\n\n  const op = {\n    q: selector,\n    u: document\n  };\n  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;\n  op.multi = options.multi !== void 0 ? !!options.multi : false;\n\n  if (options.hint) {\n    op.hint = options.hint;\n  }\n\n  if (finalOptions.arrayFilters) {\n    op.arrayFilters = finalOptions.arrayFilters;\n    delete finalOptions.arrayFilters;\n  }\n\n  if (finalOptions.retryWrites && op.multi) {\n    finalOptions.retryWrites = false;\n  } // Have we specified collation\n\n\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  } // Update options\n\n\n  coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Return the results\n\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction updateCallback(err, r, callback) {\n  if (callback == null) return;\n  if (err) return callback(err);\n  if (r == null) return callback(null, {\n    result: {\n      ok: 1\n    }\n  });\n  r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;\n  r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] // FIXME(major): should be `r.result.upserted[0]._id`\n  : null;\n  r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;\n  r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;\n  callback(null, r);\n}\n\nmodule.exports = {\n  buildCountCommand,\n  deleteCallback,\n  findAndModify,\n  indexInformation,\n  nextObject,\n  prepareDocs,\n  insertDocuments,\n  removeDocuments,\n  updateDocuments,\n  updateCallback\n};","map":null,"metadata":{},"sourceType":"script"}