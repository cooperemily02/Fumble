{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _framesync = require('framesync');\n\nvar _utils = require('../inc/utils');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Renderer = function () {\n  function Renderer(props) {\n    _classCallCheck(this, Renderer);\n\n    this.render = this.render.bind(this);\n    this.props = _extends({}, this.constructor.defaultProps, props);\n    this.state = {};\n    this.changedValues = [];\n  }\n  /**\n   * Get current state.\n   * If `key` is not defined, return entire cached state.\n   * If `key` is defined, return cached value if present.\n   * If `key` is defined and cached value is not present, read and return.\n   * @param  {string} (optional) key of value\n   * @return {value}\n   */\n\n\n  Renderer.prototype.get = function get(key) {\n    if (key) {\n      if (this.state[key] !== undefined) {\n        return this.state[key];\n      } else {\n        return this.read(key);\n      }\n    } else {\n      return this.state;\n    }\n  };\n  /**\n   * Read value according to `onRead`\n   * @param  {string} Name of property to read\n   * @return {[type]}\n   */\n\n\n  Renderer.prototype.read = function read(key) {\n    if (this.onRead) {\n      return this.onRead(key);\n    }\n  };\n  /**\n   * Update `state` with new values and schedule `render`.\n   * @param {object} values\n   * @param {value} value toset\n   */\n\n\n  Renderer.prototype.set = function set() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (typeof args[1] === 'undefined') {\n      var values = args[0]; // Set multiple values\n\n      for (var key in values) {\n        this.setValue(key, values[key]);\n      }\n    } else {\n      var _key2 = args[0],\n          value = args[1];\n      this.setValue(_key2, value);\n    }\n\n    if (this.hasChanged) {\n      (0, _framesync.onFrameRender)(this.render);\n    }\n\n    return this;\n  }; // > Wiley - 6 in the Morning\n\n  /**\n   * Set a single value\n   * If a string or number, set directly.\n   * If an object or array, create new object or array\n   * if it doesn't already exist. Then shallow compare\n   * to set and compare individual values.\n   * One of the clearer drawbacks and annoyances with\n   * using mutable instead of immutable states.\n   * @param {[type]} key\n   * @param {[type]} value\n   */\n\n\n  Renderer.prototype.setValue = function setValue(key, value) {\n    var currentValue = this.state[key]; // If number or string, set directly\n\n    if ((0, _utils.isNum)(value) || (0, _utils.isString)(value)) {\n      if (currentValue !== value) {\n        this.state[key] = value;\n        this.hasChanged = true;\n      }\n    } else if ((0, _utils.isArray)(value)) {\n      if (!currentValue) {\n        this.state[key] = [];\n      }\n\n      var numValues = value.length;\n\n      for (var i = 0; i < numValues; i++) {\n        if (this.state[key][i] !== value[i]) {\n          this.state[key][i] = value[i];\n          this.hasChanged = true;\n        }\n      }\n    } else if ((0, _utils.isObj)(value)) {\n      if (!currentValue) {\n        this.state[key] = {};\n      }\n\n      for (var valueKey in value) {\n        if (this.state[key][valueKey] !== value[valueKey]) {\n          this.state[key][valueKey] = value[valueKey];\n          this.hasChanged = true;\n        }\n      }\n    }\n\n    if (this.hasChanged && this.changedValues.indexOf(key) === -1) {\n      this.changedValues.push(key);\n    }\n  };\n  /**\n   * Fires `onRender` if values have changed or `forceRender`\n   * is set to true.\n   * @return {this}\n   */\n\n\n  Renderer.prototype.render = function render() {\n    var forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if ((forceRender || this.hasChanged) && this.onRender) {\n      this.onRender();\n    }\n\n    this.changedValues.length = 0;\n    this.hasChanged = false;\n    return this;\n  };\n\n  return Renderer;\n}();\n\nexports.default = Renderer;","map":{"version":3,"sources":["../../src/renderers/index.js"],"names":["Renderer","get","key","read","set","args","values","value","setValue","currentValue","numValues","i","render","forceRender"],"mappings":";;;;;;;;;;;;;;;;;;AAAA,IAAA,UAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;;;;;;;IAEMA,Q;AACJ,WAAA,QAAA,CAAA,KAAA,EAAmB;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,CAAA;;AACjB,SAAA,MAAA,GAAc,KAAA,MAAA,CAAA,IAAA,CAAd,IAAc,CAAd;AAEA,SAAA,KAAA,GAAA,QAAA,CAAA,EAAA,EACK,KAAA,WAAA,CADL,YAAA,EAAA,KAAA,CAAA;AAKA,SAAA,KAAA,GAAA,EAAA;AACA,SAAA,aAAA,GAAA,EAAA;AACD;AAED;;;;;;;;;;qBAQAC,G,gBAAIC,G,EAAK;AACP,QAAA,GAAA,EAAS;AACP,UAAI,KAAA,KAAA,CAAA,GAAA,MAAJ,SAAA,EAAmC;AACjC,eAAO,KAAA,KAAA,CAAP,GAAO,CAAP;AADF,OAAA,MAEO;AACL,eAAO,KAAA,IAAA,CAAP,GAAO,CAAP;AACD;AALH,KAAA,MAMO;AACL,aAAO,KAAP,KAAA;AACD;;AAGH;;;;;;;qBAKAC,I,iBAAKD,G,EAAK;AACR,QAAI,KAAJ,MAAA,EAAiB;AACf,aAAO,KAAA,MAAA,CAAP,GAAO,CAAP;AACD;;AAGH;;;;;;;qBAKAE,G,kBAAa;AAAA,SAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAANC,IAAM,GAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAANA,MAAAA,IAAM,CAAA,IAAA,CAANA,GAAM,SAAA,CAAA,IAAA,CAANA;AAAM;;AACX,QAAI,OAAOA,IAAAA,CAAP,CAAOA,CAAP,KAAJ,WAAA,EAAoC;AAAA,UAC1BC,MAD0B,GACfD,IADe,CAAA,CAAA,CAAA,CAAA,CAElC;;AACA,WAAK,IAAL,GAAA,IAAA,MAAA,EAA0B;AACxB,aAAA,QAAA,CAAA,GAAA,EAAmBC,MAAAA,CAAnB,GAAmBA,CAAnB;AACD;AALH,KAAA,MAMO;AAAA,UACGJ,KADH,GACkBG,IADlB,CAAA,CAAA,CAAA;AAAA,UACQE,KADR,GACkBF,IADlB,CAAA,CAAA,CAAA;AAEL,WAAA,QAAA,CAAA,KAAA,EAAA,KAAA;AACD;;AAED,QAAI,KAAJ,UAAA,EAAqB;AACnB,OAAA,GAAA,UAAA,CAAA,aAAA,EAAc,KAAd,MAAA;AACD;;AAED,WAAA,IAAA;KAGF;;AACA;;;;;;;;;;;;;qBAWAG,Q,qBAASN,G,EAAKK,K,EAAO;AACnB,QAAME,YAAAA,GAAe,KAAA,KAAA,CAArB,GAAqB,CAArB,CADmB,CAGnB;;AACA,QAAI,CAAA,GAAA,MAAA,CAAA,KAAA,EAAA,KAAA,KAAgB,CAAA,GAAA,MAAA,CAAA,QAAA,EAApB,KAAoB,CAApB,EAAqC;AACnC,UAAIA,YAAAA,KAAJ,KAAA,EAA4B;AAC1B,aAAA,KAAA,CAAA,GAAA,IAAA,KAAA;AACA,aAAA,UAAA,GAAA,IAAA;AACD;AAJH,KAAA,MAKO,IAAI,CAAA,GAAA,MAAA,CAAA,OAAA,EAAJ,KAAI,CAAJ,EAAoB;AACzB,UAAI,CAAJ,YAAA,EAAmB;AACjB,aAAA,KAAA,CAAA,GAAA,IAAA,EAAA;AACD;;AAED,UAAMC,SAAAA,GAAYH,KAAAA,CAAlB,MAAA;;AACA,WAAK,IAAII,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAhB,SAAA,EAA+BA,CAA/B,EAAA,EAAoC;AAClC,YAAI,KAAA,KAAA,CAAA,GAAA,EAAA,CAAA,MAAuBJ,KAAAA,CAA3B,CAA2BA,CAA3B,EAAqC;AACnC,eAAA,KAAA,CAAA,GAAA,EAAA,CAAA,IAAqBA,KAAAA,CAArB,CAAqBA,CAArB;AACA,eAAA,UAAA,GAAA,IAAA;AACD;AACF;AAXI,KAAA,MAYA,IAAI,CAAA,GAAA,MAAA,CAAA,KAAA,EAAJ,KAAI,CAAJ,EAAkB;AACvB,UAAI,CAAJ,YAAA,EAAmB;AACjB,aAAA,KAAA,CAAA,GAAA,IAAA,EAAA;AACD;;AAED,WAAK,IAAL,QAAA,IAAA,KAAA,EAA4B;AAC1B,YAAI,KAAA,KAAA,CAAA,GAAA,EAAA,QAAA,MAA8BA,KAAAA,CAAlC,QAAkCA,CAAlC,EAAmD;AACjD,eAAA,KAAA,CAAA,GAAA,EAAA,QAAA,IAA4BA,KAAAA,CAA5B,QAA4BA,CAA5B;AACA,eAAA,UAAA,GAAA,IAAA;AACD;AACF;AACF;;AAED,QAAI,KAAA,UAAA,IAAmB,KAAA,aAAA,CAAA,OAAA,CAAA,GAAA,MAAoC,CAA3D,CAAA,EAA+D;AAC7D,WAAA,aAAA,CAAA,IAAA,CAAA,GAAA;AACD;;AAGH;;;;;;;qBAKAK,M,qBAA4B;AAAA,QAArBC,WAAqB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAP,KAAO;;AAC1B,QAAI,CAACA,WAAAA,IAAe,KAAhB,UAAA,KAAoC,KAAxC,QAAA,EAAuD;AACrD,WAAA,QAAA;AACD;;AAED,SAAA,aAAA,CAAA,MAAA,GAAA,CAAA;AACA,SAAA,UAAA,GAAA,KAAA;AAEA,WAAA,IAAA;;;;;;kBAIWb,Q","sourcesContent":["import { onFrameRender } from 'framesync';\nimport { isArray, isObj, isNum, isString } from '../inc/utils';\n\nclass Renderer {\n  constructor(props) {\n    this.render = this.render.bind(this);\n\n    this.props = {\n      ...this.constructor.defaultProps,\n      ...props\n    };\n\n    this.state = {};\n    this.changedValues = [];\n  }\n\n  /**\n   * Get current state.\n   * If `key` is not defined, return entire cached state.\n   * If `key` is defined, return cached value if present.\n   * If `key` is defined and cached value is not present, read and return.\n   * @param  {string} (optional) key of value\n   * @return {value}\n   */\n  get(key) {\n    if (key) {\n      if (this.state[key] !== undefined) {\n        return this.state[key];\n      } else {\n        return this.read(key);\n      }\n    } else {\n      return this.state;\n    }\n  }\n\n  /**\n   * Read value according to `onRead`\n   * @param  {string} Name of property to read\n   * @return {[type]}\n   */\n  read(key) {\n    if (this.onRead) {\n      return this.onRead(key);\n    }\n  }\n\n  /**\n   * Update `state` with new values and schedule `render`.\n   * @param {object} values\n   * @param {value} value toset\n   */\n  set(...args) {\n    if (typeof args[1] === 'undefined') {\n      const [ values ] = args;\n      // Set multiple values\n      for (const key in values) {\n        this.setValue(key, values[key]);\n      }\n    } else {\n      const [ key, value ] = args;\n      this.setValue(key, value);\n    }\n\n    if (this.hasChanged) {\n      onFrameRender(this.render);\n    }\n\n    return this;\n  }\n\n  // > Wiley - 6 in the Morning\n  /**\n   * Set a single value\n   * If a string or number, set directly.\n   * If an object or array, create new object or array\n   * if it doesn't already exist. Then shallow compare\n   * to set and compare individual values.\n   * One of the clearer drawbacks and annoyances with\n   * using mutable instead of immutable states.\n   * @param {[type]} key\n   * @param {[type]} value\n   */\n  setValue(key, value) {\n    const currentValue = this.state[key];\n\n    // If number or string, set directly\n    if (isNum(value) || isString(value)) {\n      if (currentValue !== value) {\n        this.state[key] = value;\n        this.hasChanged = true;\n      }\n    } else if (isArray(value)) {\n      if (!currentValue) {\n        this.state[key] = [];\n      }\n\n      const numValues = value.length;\n      for (let i = 0; i < numValues; i++) {\n        if (this.state[key][i] !== value[i]) {\n          this.state[key][i] = value[i];\n          this.hasChanged = true;\n        }\n      }\n    } else if (isObj(value)) {\n      if (!currentValue) {\n        this.state[key] = {};\n      }\n\n      for (let valueKey in value) {\n        if (this.state[key][valueKey] !== value[valueKey]) {\n          this.state[key][valueKey] = value[valueKey];\n          this.hasChanged = true;\n        }\n      }\n    }\n\n    if (this.hasChanged && this.changedValues.indexOf(key) === -1) {\n      this.changedValues.push(key);\n    }\n  }\n\n  /**\n   * Fires `onRender` if values have changed or `forceRender`\n   * is set to true.\n   * @return {this}\n   */\n  render(forceRender = false) {\n    if ((forceRender || this.hasChanged) && this.onRender) {\n      this.onRender();\n    }\n\n    this.changedValues.length = 0;\n    this.hasChanged = false;\n\n    return this;\n  }\n}\n\nexport default Renderer;\n"]},"metadata":{},"sourceType":"script"}