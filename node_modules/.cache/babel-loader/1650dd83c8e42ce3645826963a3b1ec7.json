{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.bezier = exports.blendColor = exports.alpha = exports.color = exports.hsla = exports.rgba = exports.rgbUnit = exports.px = exports.degrees = exports.percent = exports.transformChildValues = exports.steps = exports.snap = exports.smooth = exports.wrap = exports.nonlinearSpring = exports.spring = exports.generateNonIntergratedSpring = exports.multiply = exports.divide = exports.add = exports.subtract = exports.interpolate = exports.flow = exports.pipe = exports.conditional = exports.clamp = exports.clampMin = exports.clampMax = exports.applyOffset = exports.appendUnit = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _calc = require('./calc');\n\nvar _utils = require('./utils');\n\nvar _parsers = require('./parsers');\n\nvar _framesync = require('framesync');\n\nvar noop = function noop(v) {\n  return v;\n};\n/**\n * Append Unit\n * A function that will append\n * appendUnit('px', 20) -> '20px'\n * @param  {string} unit)\n * @return {number}\n */\n\n\nvar appendUnit = exports.appendUnit = function appendUnit(unit) {\n  return function (v) {\n    return '' + v + unit;\n  };\n};\n/**\n * Apply offset\n * A function that, given a value, will get the offset from `from`\n * and apply it to `to`\n * @param  {number} from\n * @param  {number} to\n * @return {function}\n */\n\n\nvar applyOffset = exports.applyOffset = function applyOffset(from, to) {\n  var getOffset = subtract(from);\n  var applyOffsetTo = add(to);\n  return function (v) {\n    return applyOffsetTo(getOffset(v));\n  };\n};\n/**\n * Clamp value between\n * Creates a function that will restrict a given value between `min` and `max`\n * @param  {number} min\n * @param  {number} max\n * @return {number}\n */\n\n\nvar clampMax = exports.clampMax = function clampMax(max) {\n  return function (v) {\n    return Math.min(v, max);\n  };\n};\n\nvar clampMin = exports.clampMin = function clampMin(min) {\n  return function (v) {\n    return Math.max(v, min);\n  };\n};\n\nvar clamp = exports.clamp = function clamp(min, max) {\n  var _min = clampMin(min);\n\n  var _max = clampMax(max);\n\n  return function (v) {\n    return _min(_max(v));\n  };\n};\n\nvar conditional = exports.conditional = function conditional(condition, ifTrue) {\n  var ifFalse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n  return function (v, action) {\n    return condition(v, action) ? ifTrue(v, action) : ifFalse(v, action);\n  };\n};\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\n\n\nvar pipe = exports.pipe = function pipe() {\n  for (var _len = arguments.length, transformers = Array(_len), _key = 0; _key < _len; _key++) {\n    transformers[_key] = arguments[_key];\n  }\n\n  var numTransformers = transformers.length;\n  var i = 0;\n  return function (acc) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var v = acc;\n\n    for (i = 0; i < numTransformers; i++) {\n      v = transformers[i].apply(transformers, [v].concat(args));\n    }\n\n    return v;\n  };\n}; // Deprecated: Remove in 7.1.0\n\n\nvar flow = exports.flow = pipe;\n/**\n * Interpolate from set of values to another\n * @param  {Array} input array\n * @param  {Array} output\n * @param  {Function} rangeEasing\n * @return {Function}\n */\n\nvar interpolate = exports.interpolate = function interpolate(input, output, rangeEasing) {\n  var rangeLength = input.length;\n  var finalIndex = rangeLength - 1;\n  return function (v) {\n    // If value outside minimum range, quickly return\n    if (v <= input[0]) {\n      return output[0];\n    } // If value outside maximum range, quickly return\n\n\n    if (v >= input[finalIndex]) {\n      return output[finalIndex];\n    }\n\n    var i = 1; // Find index of range start\n\n    for (; i < rangeLength; i++) {\n      if (input[i] > v || i === finalIndex) {\n        break;\n      }\n    }\n\n    var progressInRange = (0, _calc.getProgressFromValue)(input[i - 1], input[i], v);\n    var easedProgress = rangeEasing ? rangeEasing[i - 1](progressInRange) : progressInRange;\n    return (0, _calc.getValueFromProgress)(output[i - 1], output[i], easedProgress);\n  };\n};\n\nvar subtract = exports.subtract = function subtract(origin) {\n  return function (v) {\n    return v - origin;\n  };\n};\n\nvar add = exports.add = function add(origin) {\n  return function (v) {\n    return v + origin;\n  };\n};\n\nvar divide = exports.divide = function divide(origin) {\n  return function (v) {\n    return v / origin;\n  };\n};\n\nvar multiply = exports.multiply = function multiply(origin) {\n  return function (v) {\n    return v * origin;\n  };\n};\n\nvar generateNonIntergratedSpring = exports.generateNonIntergratedSpring = function generateNonIntergratedSpring() {\n  var alterDisplacement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;\n  return function (constant, origin) {\n    return function (v) {\n      var displacement = origin - v;\n      var springModifiedDisplacement = -constant * (0 - alterDisplacement(Math.abs(displacement)));\n      return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;\n    };\n  };\n};\n\nvar spring = exports.spring = generateNonIntergratedSpring();\nvar nonlinearSpring = exports.nonlinearSpring = generateNonIntergratedSpring(Math.sqrt);\n\nvar wrap = exports.wrap = function wrap(min, max) {\n  return function (v) {\n    var rangeSize = max - min;\n    return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n  };\n};\n\nvar smooth = exports.smooth = function smooth() {\n  var strength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n  var previousValue = 0;\n  var lastUpdated = 0;\n  return function (v) {\n    var currentFramestamp = (0, _framesync.currentFrameTime)();\n    var timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;\n    var newValue = timeDelta ? (0, _calc.smooth)(v, previousValue, timeDelta, strength) : previousValue;\n    lastUpdated = currentFramestamp;\n    previousValue = newValue;\n    return newValue;\n  };\n};\n\nvar snap = exports.snap = function snap(points) {\n  if (typeof points === 'number') {\n    return function (v) {\n      return Math.round(v / points) * points;\n    };\n  } else {\n    var i = 0;\n    var numPoints = points.length;\n    return function (v) {\n      var lastDistance = Math.abs(points[0] - v);\n\n      for (i = 1; i < numPoints; i++) {\n        var point = points[i];\n        var distance = Math.abs(point - v);\n        if (distance === 0) return point;\n        if (distance > lastDistance) return points[i - 1];\n        if (i === numPoints - 1) return point;\n        lastDistance = distance;\n      }\n    };\n  }\n};\n\nvar steps = exports.steps = function steps(_steps) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'start';\n  return function (v) {\n    var progress = (0, _calc.getProgressFromValue)(min, max, v);\n    return (0, _calc.getValueFromProgress)(min, max, (0, _calc.stepProgress)(_steps, progress, direction));\n  };\n};\n\nvar transformChildValues = exports.transformChildValues = function transformChildValues(childTransformers) {\n  var mutableState = {};\n  return function (v) {\n    for (var key in v) {\n      var childTransformer = childTransformers[key];\n\n      if (childTransformer) {\n        mutableState[key] = childTransformer(v[key]);\n      }\n    }\n\n    return mutableState;\n  };\n}; // Unit transformers\n\n\nvar percent = exports.percent = appendUnit('%');\nvar degrees = exports.degrees = appendUnit('deg');\nvar px = exports.px = appendUnit('px');\nvar rgbUnit = exports.rgbUnit = pipe(clamp(0, 255), Math.round);\n\nvar rgbaTemplate = function rgbaTemplate(_ref) {\n  var red = _ref.red,\n      green = _ref.green,\n      blue = _ref.blue,\n      _ref$alpha = _ref.alpha,\n      alpha = _ref$alpha === undefined ? 1 : _ref$alpha;\n  return 'rgba(' + red + ', ' + green + ', ' + blue + ', ' + alpha + ')';\n};\n\nvar rgba = exports.rgba = pipe(transformChildValues({\n  red: rgbUnit,\n  green: rgbUnit,\n  blue: rgbUnit,\n  alpha: alpha\n}), rgbaTemplate);\n\nvar hslaTemplate = function hslaTemplate(_ref2) {\n  var hue = _ref2.hue,\n      saturation = _ref2.saturation,\n      lightness = _ref2.lightness,\n      _ref2$alpha = _ref2.alpha,\n      alpha = _ref2$alpha === undefined ? 1 : _ref2$alpha;\n  return 'hsla(' + hue + ', ' + saturation + ', ' + lightness + ', ' + alpha + ')';\n};\n\nvar hsla = exports.hsla = pipe(transformChildValues({\n  hue: parseInt,\n  saturation: percent,\n  lightness: percent,\n  alpha: alpha\n}), hslaTemplate);\n\nvar color = exports.color = function color(v) {\n  if (v.hasOwnProperty('red')) {\n    return rgba(v);\n  } else if (v.hasOwnProperty('hue')) {\n    return hsla(v);\n  }\n\n  return v;\n};\n\nvar alpha = exports.alpha = clamp(0, 1);\n\nvar blend = function blend(from, to, v) {\n  var fromExpo = from * from;\n  var toExpo = to * to;\n  return Math.sqrt(v * (toExpo - fromExpo) + fromExpo);\n}; // http://codepen.io/osublake/pen/xGVVaN\n\n\nvar blendColor = exports.blendColor = function blendColor(from, to) {\n  var fromColor = (0, _utils.isString)(from) ? (0, _parsers.color)(from) : from;\n  var toColor = (0, _utils.isString)(to) ? (0, _parsers.color)(to) : to;\n\n  var blended = _extends({}, fromColor);\n\n  return function (v) {\n    for (var key in blended) {\n      blended[key] = blend(fromColor[key], toColor[key], v);\n    }\n\n    blended.red = blend(fromColor.red, toColor.red, v);\n    blended.green = blend(fromColor.green, toColor.green, v);\n    blended.blue = blend(fromColor.blue, toColor.blue, v);\n    blended.alpha = (0, _calc.getValueFromProgress)(fromColor.alpha, toColor.alpha, v);\n    return blended;\n  };\n}; // Bezier resolver\n// Refactored from https://github.com/hughsk/bezier/blob/master/index.js\n\n/**\n## The MIT License (MIT) ##\n\nCopyright (c) 2013 Hugh Kennedy\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n */\n\n\nvar resolve3 = function resolve3(points) {\n  return function (t) {\n    var ut = 1 - t;\n    return (points[0] * ut + points[1] * t) * ut + (points[1] * ut + points[2] * t) * t;\n  };\n};\n\nvar resolve4 = function resolve4(points) {\n  return function (t) {\n    var ut = 1 - t;\n    var a1 = points[1] * ut + points[2] * t;\n    return ((points[0] * ut + points[1] * t) * ut + a1 * t) * ut + (a1 * ut + (points[2] * ut + points[3] * t) * t) * t;\n  };\n};\n\nvar bezier = exports.bezier = function bezier(points) {\n  return points.length === 3 ? resolve3(points) : resolve4(points);\n};","map":{"version":3,"sources":["../../src/inc/transformers.js"],"names":["noop","appendUnit","applyOffset","getOffset","subtract","applyOffsetTo","add","clampMax","Math","clampMin","clamp","_min","_max","conditional","ifFalse","condition","ifTrue","pipe","transformers","numTransformers","i","args","v","flow","interpolate","rangeLength","input","finalIndex","output","progressInRange","easedProgress","rangeEasing","divide","multiply","generateNonIntergratedSpring","alterDisplacement","displacement","origin","springModifiedDisplacement","spring","nonlinearSpring","wrap","rangeSize","max","smooth","strength","previousValue","lastUpdated","currentFramestamp","timeDelta","newValue","snap","numPoints","points","lastDistance","point","distance","steps","min","direction","progress","transformChildValues","mutableState","childTransformer","childTransformers","percent","degrees","px","rgbUnit","rgbaTemplate","red","green","blue","alpha","rgba","hslaTemplate","hue","saturation","lightness","hsla","color","blend","fromExpo","from","toExpo","to","blendColor","fromColor","toColor","blended","resolve3","ut","resolve4","a1","bezier"],"mappings":"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","sourcesContent":["import { getProgressFromValue, getValueFromProgress, stepProgress, smooth as calcSmoothing } from './calc';\nimport { isString } from './utils';\nimport { color as parseColor } from './parsers';\nimport { currentFrameTime } from 'framesync';\n\nconst noop = (v) => v;\n\n/**\n * Append Unit\n * A function that will append\n * appendUnit('px', 20) -> '20px'\n * @param  {string} unit)\n * @return {number}\n */\nexport const appendUnit = (unit) => (v) => `${v}${unit}`;\n\n/**\n * Apply offset\n * A function that, given a value, will get the offset from `from`\n * and apply it to `to`\n * @param  {number} from\n * @param  {number} to\n * @return {function}\n */\nexport const applyOffset = (from, to) => {\n  const getOffset = subtract(from);\n  const applyOffsetTo = add(to);\n  return (v) => applyOffsetTo(getOffset(v));\n};\n\n/**\n * Clamp value between\n * Creates a function that will restrict a given value between `min` and `max`\n * @param  {number} min\n * @param  {number} max\n * @return {number}\n */\nexport const clampMax = (max) => (v) => Math.min(v, max);\nexport const clampMin = (min) => (v) => Math.max(v, min);\nexport const clamp = (min, max) => {\n  const _min = clampMin(min);\n  const _max = clampMax(max);\n  return (v) => _min(_max(v));\n};\n\nexport const conditional = (condition, ifTrue, ifFalse = noop) => (v, action) => {\n  return condition(v, action) ? ifTrue(v, action) : ifFalse(v, action);\n};\n\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nexport const pipe = (...transformers) => {\n  const numTransformers = transformers.length;\n  let i = 0;\n\n  return (acc, ...args) => {\n    let v = acc;\n    for (i = 0; i < numTransformers; i++) {\n      v = transformers[i](v, ...args);\n    }\n\n    return v;\n  };\n};\n\n// Deprecated: Remove in 7.1.0\nexport const flow = pipe;\n\n/**\n * Interpolate from set of values to another\n * @param  {Array} input array\n * @param  {Array} output\n * @param  {Function} rangeEasing\n * @return {Function}\n */\nexport const interpolate = (input, output, rangeEasing) => {\n  const rangeLength = input.length;\n  const finalIndex = rangeLength - 1;\n\n  return (v) => {\n    // If value outside minimum range, quickly return\n    if (v <= input[0]) {\n      return output[0];\n    }\n\n    // If value outside maximum range, quickly return\n    if (v >= input[finalIndex]) {\n      return output[finalIndex];\n    }\n\n    let i = 1;\n\n    // Find index of range start\n    for (; i < rangeLength; i++) {\n      if (input[i] > v || i === finalIndex) {\n        break;\n      }\n    }\n\n    const progressInRange = getProgressFromValue(input[i - 1], input[i], v);\n    const easedProgress = (rangeEasing) ? rangeEasing[i - 1](progressInRange) : progressInRange;\n    return getValueFromProgress(output[i - 1], output[i], easedProgress);\n  };\n};\n\nexport const subtract = (origin) => (v) => v - origin;\nexport const add = (origin) => (v) => v + origin;\nexport const divide = (origin) => (v) => v / origin;\nexport const multiply = (origin) => (v) => v * origin;\n\nexport const generateNonIntergratedSpring = (alterDisplacement = noop) => (constant, origin) => (v) => {\n  const displacement = origin - v;\n  const springModifiedDisplacement = - constant * (0 - alterDisplacement(Math.abs(displacement)));\n  return (displacement <= 0) ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;\n};\n\nexport const spring = generateNonIntergratedSpring();\nexport const nonlinearSpring = generateNonIntergratedSpring(Math.sqrt);\n\nexport const wrap = (min, max) => (v) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\nexport const smooth = (strength = 50) => {\n  let previousValue = 0;\n  let lastUpdated = 0;\n\n  return (v) => {\n    const currentFramestamp = currentFrameTime();\n    const timeDelta = (currentFramestamp !== lastUpdated) ? currentFramestamp - lastUpdated : 0;\n    const newValue = timeDelta ? calcSmoothing(v, previousValue, timeDelta, strength) : previousValue;\n    lastUpdated = currentFramestamp;\n    previousValue = newValue;\n    return newValue;\n  };\n};\n\nexport const snap = (points) => {\n  if (typeof points === 'number') {\n    return (v) => Math.round(v / points) * points;\n  } else {\n    let i = 0;\n    const numPoints = points.length;\n\n    return (v) => {\n      let lastDistance = Math.abs(points[0] - v);\n\n      for (i = 1; i < numPoints; i++) {\n        const point = points[i];\n        const distance = Math.abs(point - v);\n\n        if (distance === 0) return point;\n\n        if (distance > lastDistance) return points[i - 1];\n\n        if (i === numPoints - 1) return point;\n\n        lastDistance = distance;\n      }\n    };\n  }\n};\n\nexport const steps = (steps, min = 0, max = 1, direction = 'start') => (v) => {\n  const progress = getProgressFromValue(min, max, v);\n  return getValueFromProgress(min, max, stepProgress(steps, progress, direction));\n};\n\nexport const transformChildValues = (childTransformers) => {\n  const mutableState = {};\n  return (v) => {\n    for (let key in v) {\n      const childTransformer = childTransformers[key];\n      if (childTransformer) {\n        mutableState[key] = childTransformer(v[key]);\n      }\n    }\n\n    return mutableState;\n  };\n};\n\n// Unit transformers\nexport const percent = appendUnit('%');\nexport const degrees = appendUnit('deg');\nexport const px = appendUnit('px');\n\nexport const rgbUnit = pipe(\n  clamp(0, 255),\n  Math.round\n);\n\nconst rgbaTemplate = ({ red, green, blue, alpha = 1 }) =>\n  `rgba(${red}, ${green}, ${blue}, ${alpha})`;\n\nexport const rgba = pipe(\n  transformChildValues({\n    red: rgbUnit,\n    green: rgbUnit,\n    blue: rgbUnit,\n    alpha\n  }),\n  rgbaTemplate\n);\n\nconst hslaTemplate = ({ hue, saturation, lightness, alpha = 1 }) =>\n  `hsla(${hue}, ${saturation}, ${lightness}, ${alpha})`;\n\nexport const hsla = pipe(\n  transformChildValues({\n    hue: parseInt,\n    saturation: percent,\n    lightness: percent,\n    alpha\n  }),\n  hslaTemplate\n);\n\nexport const color = (v) => {\n  if (v.hasOwnProperty('red')) {\n    return rgba(v);\n  } else if (v.hasOwnProperty('hue')) {\n    return hsla(v);\n  }\n  return v;\n};\n\nexport const alpha = clamp(0, 1);\n\nconst blend = (from, to, v) => {\n  const fromExpo = from * from;\n  const toExpo = to * to;\n  return Math.sqrt(v * (toExpo - fromExpo) + fromExpo);\n};\n// http://codepen.io/osublake/pen/xGVVaN\nexport const blendColor = (from, to) => {\n  const fromColor = isString(from) ? parseColor(from) : from;\n  const toColor = isString(to) ? parseColor(to): to;\n\n  const blended = { ...fromColor };\n\n  return (v) => {\n    for (let key in blended) {\n      blended[key] = blend(fromColor[key], toColor[key], v);\n    }\n    blended.red = blend(fromColor.red, toColor.red, v);\n    blended.green = blend(fromColor.green, toColor.green, v);\n    blended.blue = blend(fromColor.blue, toColor.blue, v);\n    blended.alpha = getValueFromProgress(fromColor.alpha, toColor.alpha, v);\n    return blended;\n  };\n};\n\n// Bezier resolver\n// Refactored from https://github.com/hughsk/bezier/blob/master/index.js\n/**\n## The MIT License (MIT) ##\n\nCopyright (c) 2013 Hugh Kennedy\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n */\nconst resolve3 = (points) => (t) => {\n  const ut = 1 - t;\n  return (points[0] * ut + points[1] * t) * ut + (points[1] * ut + points[2] * t) * t;\n};\n\nconst resolve4 = (points) => (t) => {\n  const ut = 1 - t;\n  const a1 = points[1] * ut + points[2] * t;\n  return ((points[0] * ut + points[1] * t) * ut + a1 * t) * ut + (a1 * ut + (points[2] * ut + points[3] * t) * t) * t;\n};\n\nexport const bezier = (points) =>\n  (points.length === 3) ? resolve3(points) : resolve4(points);\n"]},"metadata":{},"sourceType":"script"}