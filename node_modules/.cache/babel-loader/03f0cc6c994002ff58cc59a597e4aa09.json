{"ast":null,"code":"'use strict';\n\nconst Msg = require('../connection/msg').Msg;\n\nconst KillCursor = require('../connection/commands').KillCursor;\n\nconst GetMore = require('../connection/commands').GetMore;\n\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n/** Commands that we want to redact because of the sensitive nature of their contents */\n\n\nconst SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']); // helper methods\n\nconst extractCommandName = commandDoc => Object.keys(commandDoc)[0];\n\nconst namespace = command => command.ns;\n\nconst databaseName = command => command.ns.split('.')[0];\n\nconst collectionName = command => command.ns.split('.')[1];\n\nconst generateConnectionId = pool => pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;\n\nconst maybeRedact = (commandName, result) => SENSITIVE_COMMANDS.has(commandName) ? {} : result;\n\nconst isLegacyPool = pool => pool.s && pool.queue;\n\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldsSelector: 'projection'\n};\nconst OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];\n/**\n * Extract the actual command from the query, possibly upconverting if it's a legacy\n * format\n *\n * @param {Object} command the command\n */\n\nconst extractCommand = command => {\n  if (command instanceof GetMore) {\n    return {\n      getMore: command.cursorId,\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      killCursors: collectionName(command),\n      cursors: command.cursorIds\n    };\n  }\n\n  if (command instanceof Msg) {\n    return command.command;\n  }\n\n  if (command.query && command.query.$query) {\n    let result;\n\n    if (command.ns === 'admin.$cmd') {\n      // upconvert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // upconvert legacy find command\n      result = {\n        find: collectionName(command)\n      };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (typeof command.query[key] !== 'undefined') result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      if (typeof command[key] !== 'undefined') result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];\n    });\n    OP_QUERY_KEYS.forEach(key => {\n      if (command[key]) result[key] = command[key];\n    });\n\n    if (typeof command.pre32Limit !== 'undefined') {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return {\n        explain: result\n      };\n    }\n\n    return result;\n  }\n\n  return command.query ? command.query : command;\n};\n\nconst extractReply = (command, reply) => {\n  if (command instanceof GetMore) {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        nextBatch: reply.message.documents\n      }\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      ok: 1,\n      cursorsUnknown: command.cursorIds\n    };\n  } // is this a legacy find command?\n\n\n  if (command.query && typeof command.query.$query !== 'undefined') {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        firstBatch: reply.message.documents\n      }\n    };\n  }\n\n  return reply && reply.result ? reply.result : reply;\n};\n\nconst extractConnectionDetails = pool => {\n  if (isLegacyPool(pool)) {\n    return {\n      connectionId: generateConnectionId(pool)\n    };\n  } // APM in the modern pool is done at the `Connection` level, so we rename it here for\n  // readability.\n\n\n  const connection = pool;\n  return {\n    address: connection.address,\n    connectionId: connection.id\n  };\n};\n/** An event indicating the start of a given command */\n\n\nclass CommandStartedEvent {\n  /**\n   * Create a started event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   */\n  constructor(pool, command) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool); // NOTE: remove in major revision, this is not spec behavior\n\n    if (SENSITIVE_COMMANDS.has(commandName)) {\n      this.commandObj = {};\n      this.commandObj[commandName] = true;\n    }\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      databaseName: databaseName(command),\n      commandName,\n      command: cmd\n    });\n  }\n\n}\n/** An event indicating the success of a given command */\n\n\nclass CommandSucceededEvent {\n  /**\n   * Create a succeeded event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {Object} reply the reply for this command from the server\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, reply, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      reply: maybeRedact(commandName, extractReply(command, reply))\n    });\n  }\n\n}\n/** An event indicating the failure of a given command */\n\n\nclass CommandFailedEvent {\n  /**\n   * Create a failure event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {MongoError|Object} error the generated error or a server error response\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, error, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      failure: maybeRedact(commandName, error)\n    });\n  }\n\n}\n\nmodule.exports = {\n  CommandStartedEvent,\n  CommandSucceededEvent,\n  CommandFailedEvent\n};","map":null,"metadata":{},"sourceType":"script"}