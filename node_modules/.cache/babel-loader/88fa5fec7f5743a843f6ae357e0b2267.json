{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst inherits = require('util').inherits;\n\nconst getSingleProperty = require('./utils').getSingleProperty;\n\nconst CommandCursor = require('./command_cursor');\n\nconst handleCallback = require('./utils').handleCallback;\n\nconst filterOptions = require('./utils').filterOptions;\n\nconst toError = require('./utils').toError;\n\nconst ReadPreference = require('./core').ReadPreference;\n\nconst MongoError = require('./core').MongoError;\n\nconst ObjectID = require('./core').ObjectID;\n\nconst Logger = require('./core').Logger;\n\nconst Collection = require('./collection');\n\nconst mergeOptionsAndWriteConcern = require('./utils').mergeOptionsAndWriteConcern;\n\nconst executeLegacyOperation = require('./utils').executeLegacyOperation;\n\nconst ChangeStream = require('./change_stream');\n\nconst deprecate = require('util').deprecate;\n\nconst deprecateOptions = require('./utils').deprecateOptions;\n\nconst MongoDBNamespace = require('./utils').MongoDBNamespace;\n\nconst CONSTANTS = require('./constants');\n\nconst WriteConcern = require('./write_concern');\n\nconst ReadConcern = require('./read_concern');\n\nconst AggregationCursor = require('./aggregation_cursor'); // Operations\n\n\nconst createListener = require('./operations/db_ops').createListener;\n\nconst ensureIndex = require('./operations/db_ops').ensureIndex;\n\nconst evaluate = require('./operations/db_ops').evaluate;\n\nconst profilingInfo = require('./operations/db_ops').profilingInfo;\n\nconst validateDatabaseName = require('./operations/db_ops').validateDatabaseName;\n\nconst AggregateOperation = require('./operations/aggregate');\n\nconst AddUserOperation = require('./operations/add_user');\n\nconst CollectionsOperation = require('./operations/collections');\n\nconst CommandOperation = require('./operations/command');\n\nconst RunCommandOperation = require('./operations/run_command');\n\nconst CreateCollectionOperation = require('./operations/create_collection');\n\nconst CreateIndexesOperation = require('./operations/create_indexes');\n\nconst DropCollectionOperation = require('./operations/drop').DropCollectionOperation;\n\nconst DropDatabaseOperation = require('./operations/drop').DropDatabaseOperation;\n\nconst ExecuteDbAdminCommandOperation = require('./operations/execute_db_admin_command');\n\nconst IndexInformationOperation = require('./operations/index_information');\n\nconst ListCollectionsOperation = require('./operations/list_collections');\n\nconst ProfilingLevelOperation = require('./operations/profiling_level');\n\nconst RemoveUserOperation = require('./operations/remove_user');\n\nconst RenameOperation = require('./operations/rename');\n\nconst SetProfilingLevelOperation = require('./operations/set_profiling_level');\n\nconst executeOperation = require('./operations/execute_operation');\n/**\n * @fileOverview The **Db** class is a class that represents a MongoDB Database.\n *\n * @example\n * const MongoClient = require('mongodb').MongoClient;\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Select the database by name\n *   const testDb = client.db(dbName);\n *   client.close();\n * });\n */\n// Allowed parameters\n\n\nconst legalOptionNames = ['w', 'wtimeout', 'fsync', 'j', 'readPreference', 'readPreferenceTags', 'native_parser', 'forceServerObjectId', 'pkFactory', 'serializeFunctions', 'raw', 'bufferMaxEntries', 'authSource', 'ignoreUndefined', 'promoteLongs', 'promiseLibrary', 'readConcern', 'retryMiliSeconds', 'numberOfRetries', 'parentDb', 'noListener', 'loggerLevel', 'logger', 'promoteBuffers', 'promoteLongs', 'promoteValues', 'compression', 'retryWrites'];\n/**\n * Creates a new Db instance\n * @class\n * @param {string} databaseName The name of the database this instance represents.\n * @param {(Server|ReplSet|Mongos)} topology The server topology for the database.\n * @param {object} [options] Optional settings.\n * @param {string} [options.authSource] If the database authentication is dependent on another databaseName.\n * @param {(number|string)} [options.w] The write concern.\n * @param {number} [options.wtimeout] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {number} [options.bufferMaxEntries=-1] Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {object} [options.pkFactory] A primary key factory object for generation of custom _id keys.\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\n * @param {object} [options.readConcern] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)\n * @param {ReadConcernLevel} [options.readConcern.level='local'] Specify a read concern level for the collection operations (only MongoDB 3.2 or higher supported)\n * @property {(Server|ReplSet|Mongos)} serverConfig Get the current db topology.\n * @property {number} bufferMaxEntries Current bufferMaxEntries value for the database\n * @property {string} databaseName The name of the database this instance represents.\n * @property {object} options The options associated with the db instance.\n * @property {boolean} native_parser The current value of the parameter native_parser.\n * @property {boolean} slaveOk The current slaveOk value for the db instance.\n * @property {object} writeConcern The current write concern values.\n * @property {object} topology Access the topology object (single server, replicaset or mongos).\n * @fires Db#close\n * @fires Db#reconnect\n * @fires Db#error\n * @fires Db#timeout\n * @fires Db#parseError\n * @fires Db#fullsetup\n * @return {Db} a Db instance.\n */\n\nfunction Db(databaseName, topology, options) {\n  options = options || {};\n  if (!(this instanceof Db)) return new Db(databaseName, topology, options);\n  EventEmitter.call(this); // Get the promiseLibrary\n\n  const promiseLibrary = options.promiseLibrary || Promise; // Filter the options\n\n  options = filterOptions(options, legalOptionNames); // Ensure we put the promiseLib in the options\n\n  options.promiseLibrary = promiseLibrary; // Internal state of the db object\n\n  this.s = {\n    // DbCache\n    dbCache: {},\n    // Children db's\n    children: [],\n    // Topology\n    topology: topology,\n    // Options\n    options: options,\n    // Logger instance\n    logger: Logger('Db', options),\n    // Get the bson parser\n    bson: topology ? topology.bson : null,\n    // Unpack read preference\n    readPreference: ReadPreference.fromOptions(options),\n    // Set buffermaxEntries\n    bufferMaxEntries: typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : -1,\n    // Parent db (if chained)\n    parentDb: options.parentDb || null,\n    // Set up the primary key factory or fallback to ObjectID\n    pkFactory: options.pkFactory || ObjectID,\n    // Get native parser\n    nativeParser: options.nativeParser || options.native_parser,\n    // Promise library\n    promiseLibrary: promiseLibrary,\n    // No listener\n    noListener: typeof options.noListener === 'boolean' ? options.noListener : false,\n    // ReadConcern\n    readConcern: ReadConcern.fromOptions(options),\n    writeConcern: WriteConcern.fromOptions(options),\n    // Namespace\n    namespace: new MongoDBNamespace(databaseName)\n  }; // Ensure we have a valid db name\n\n  validateDatabaseName(databaseName); // Add a read Only property\n\n  getSingleProperty(this, 'serverConfig', this.s.topology);\n  getSingleProperty(this, 'bufferMaxEntries', this.s.bufferMaxEntries);\n  getSingleProperty(this, 'databaseName', this.s.namespace.db); // This is a child db, do not register any listeners\n\n  if (options.parentDb) return;\n  if (this.s.noListener) return; // Add listeners\n\n  topology.on('error', createListener(this, 'error', this));\n  topology.on('timeout', createListener(this, 'timeout', this));\n  topology.on('close', createListener(this, 'close', this));\n  topology.on('parseError', createListener(this, 'parseError', this));\n  topology.once('open', createListener(this, 'open', this));\n  topology.once('fullsetup', createListener(this, 'fullsetup', this));\n  topology.once('all', createListener(this, 'all', this));\n  topology.on('reconnect', createListener(this, 'reconnect', this));\n}\n\ninherits(Db, EventEmitter); // Topology\n\nObject.defineProperty(Db.prototype, 'topology', {\n  enumerable: true,\n  get: function () {\n    return this.s.topology;\n  }\n}); // Options\n\nObject.defineProperty(Db.prototype, 'options', {\n  enumerable: true,\n  get: function () {\n    return this.s.options;\n  }\n}); // slaveOk specified\n\nObject.defineProperty(Db.prototype, 'slaveOk', {\n  enumerable: true,\n  get: function () {\n    if (this.s.options.readPreference != null && (this.s.options.readPreference !== 'primary' || this.s.options.readPreference.mode !== 'primary')) {\n      return true;\n    }\n\n    return false;\n  }\n});\nObject.defineProperty(Db.prototype, 'readConcern', {\n  enumerable: true,\n  get: function () {\n    return this.s.readConcern;\n  }\n});\nObject.defineProperty(Db.prototype, 'readPreference', {\n  enumerable: true,\n  get: function () {\n    if (this.s.readPreference == null) {\n      // TODO: check client\n      return ReadPreference.primary;\n    }\n\n    return this.s.readPreference;\n  }\n}); // get the write Concern\n\nObject.defineProperty(Db.prototype, 'writeConcern', {\n  enumerable: true,\n  get: function () {\n    return this.s.writeConcern;\n  }\n});\nObject.defineProperty(Db.prototype, 'namespace', {\n  enumerable: true,\n  get: function () {\n    return this.s.namespace.toString();\n  }\n});\n/**\n * Execute a command\n * @method\n * @param {object} command The command hash\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nDb.prototype.command = function (command, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = Object.assign({}, options);\n  const commandOperation = new RunCommandOperation(this, command, options);\n  return executeOperation(this.s.topology, commandOperation, callback);\n};\n/**\n * Execute an aggregation framework pipeline against the database, needs MongoDB >= 3.6\n * @method\n * @param {object} [pipeline=[]] Array containing all the aggregation framework commands for the execution.\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {object} [options.cursor] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.\n * @param {number} [options.cursor.batchSize=1000] Deprecated. Use `options.batchSize`\n * @param {boolean} [options.explain=false] Explain returns the aggregation execution plan (requires mongodb 2.6 >).\n * @param {boolean} [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).\n * @param {number} [options.maxTimeMS] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.\n * @param {number} [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {string} [options.comment] Add a comment to an aggregation command\n * @param {string|object} [options.hint] Add an index selection hint to an aggregation command\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Database~aggregationCallback} callback The command result callback\n * @return {(null|AggregationCursor)}\n */\n\n\nDb.prototype.aggregate = function (pipeline, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } // If we have no options or callback we are doing\n  // a cursor based aggregation\n\n\n  if (options == null && callback == null) {\n    options = {};\n  }\n\n  const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline, options), options); // TODO: remove this when NODE-2074 is resolved\n\n  if (typeof callback === 'function') {\n    callback(null, cursor);\n    return;\n  }\n\n  return cursor;\n};\n/**\n * Return the Admin db instance\n * @method\n * @return {Admin} return the new Admin db instance\n */\n\n\nDb.prototype.admin = function () {\n  const Admin = require('./admin');\n\n  return new Admin(this, this.s.topology, this.s.promiseLibrary);\n};\n/**\n * The callback format for the collection method, must be used if strict is specified\n * @callback Db~collectionResultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection} collection The collection instance.\n */\n\n/**\n * The callback format for an aggregation call\n * @callback Database~aggregationCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {AggregationCursor} cursor The cursor if the aggregation command was executed successfully.\n */\n\n\nconst collectionKeys = ['pkFactory', 'readPreference', 'serializeFunctions', 'strict', 'readConcern', 'ignoreUndefined', 'promoteValues', 'promoteBuffers', 'promoteLongs'];\n/**\n * Fetch a specific collection (containing the actual collection information). If the application does not use strict mode you\n * can use it without a callback in the following way: `const collection = db.collection('mycollection');`\n *\n * @method\n * @param {string} name the collection name we wish to access.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] The write concern.\n * @param {number} [options.wtimeout] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {object} [options.pkFactory] A primary key factory object for generation of custom _id keys.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.strict=false] Returns an error if the collection does not exist\n * @param {object} [options.readConcern] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)\n * @param {ReadConcernLevel} [options.readConcern.level='local'] Specify a read concern level for the collection operations (only MongoDB 3.2 or higher supported)\n * @param {Db~collectionResultCallback} [callback] The collection result callback\n * @return {Collection} return the new Collection instance if not in strict mode\n */\n\nDb.prototype.collection = function (name, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  options = Object.assign({}, options); // Set the promise library\n\n  options.promiseLibrary = this.s.promiseLibrary; // If we have not set a collection level readConcern set the db level one\n\n  options.readConcern = options.readConcern ? new ReadConcern(options.readConcern.level) : this.readConcern; // Do we have ignoreUndefined set\n\n  if (this.s.options.ignoreUndefined) {\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  } // Merge in all needed options and ensure correct writeConcern merging from db level\n\n\n  options = mergeOptionsAndWriteConcern(options, this.s.options, collectionKeys, true); // Execute\n\n  if (options == null || !options.strict) {\n    try {\n      const collection = new Collection(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options);\n      if (callback) callback(null, collection);\n      return collection;\n    } catch (err) {\n      if (err instanceof MongoError && callback) return callback(err);\n      throw err;\n    }\n  } // Strict mode\n\n\n  if (typeof callback !== 'function') {\n    throw toError(`A callback is required in strict mode. While getting collection ${name}`);\n  } // Did the user destroy the topology\n\n\n  if (this.serverConfig && this.serverConfig.isDestroyed()) {\n    return callback(new MongoError('topology was destroyed'));\n  }\n\n  const listCollectionOptions = Object.assign({}, options, {\n    nameOnly: true\n  }); // Strict mode\n\n  this.listCollections({\n    name: name\n  }, listCollectionOptions).toArray((err, collections) => {\n    if (err != null) return handleCallback(callback, err, null);\n    if (collections.length === 0) return handleCallback(callback, toError(`Collection ${name} does not exist. Currently in strict mode.`), null);\n\n    try {\n      return handleCallback(callback, null, new Collection(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options));\n    } catch (err) {\n      return handleCallback(callback, err, null);\n    }\n  });\n};\n/**\n * Create a new collection on a server with the specified options. Use this to create capped collections.\n * More information about command options available at https://docs.mongodb.com/manual/reference/command/create/\n *\n * @method\n * @param {string} name the collection name we wish to access.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] The write concern.\n * @param {number} [options.wtimeout] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {object} [options.pkFactory] A primary key factory object for generation of custom _id keys.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.strict=false] DEPRECATED: Returns an error if the collection does not exist\n * @param {boolean} [options.capped=false] Create a capped collection.\n * @param {boolean} [options.autoIndexId=true] DEPRECATED: Create an index on the _id field of the document, True by default on MongoDB 2.6 - 3.0\n * @param {number} [options.size] The size of the capped collection in bytes.\n * @param {number} [options.max] The maximum number of documents in the capped collection.\n * @param {number} [options.flags] Optional. Available for the MMAPv1 storage engine only to set the usePowerOf2Sizes and the noPadding flag.\n * @param {object} [options.storageEngine] Allows users to specify configuration to the storage engine on a per-collection basis when creating a collection on MongoDB 3.0 or higher.\n * @param {object} [options.validator] Allows users to specify validation rules or expressions for the collection. For more information, see Document Validation on MongoDB 3.2 or higher.\n * @param {string} [options.validationLevel] Determines how strictly MongoDB applies the validation rules to existing documents during an update on MongoDB 3.2 or higher.\n * @param {string} [options.validationAction] Determines whether to error on invalid documents or just warn about the violations but allow invalid documents to be inserted on MongoDB 3.2 or higher.\n * @param {object} [options.indexOptionDefaults] Allows users to specify a default configuration for indexes when creating a collection on MongoDB 3.2 or higher.\n * @param {string} [options.viewOn] The name of the source collection or view from which to create the view. The name is not the full namespace of the collection or view; i.e. does not include the database name and implies the same database as the view to create on MongoDB 3.4 or higher.\n * @param {array} [options.pipeline] An array that consists of the aggregation pipeline stage. Creates the view by applying the specified pipeline to the viewOn collection or view on MongoDB 3.4 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~collectionResultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.createCollection = deprecateOptions({\n  name: 'Db.createCollection',\n  deprecatedOptions: ['autoIndexId', 'strict'],\n  optionsIndex: 1\n}, function (name, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;\n  options.readConcern = options.readConcern ? new ReadConcern(options.readConcern.level) : this.readConcern;\n  const createCollectionOperation = new CreateCollectionOperation(this, name, options);\n  return executeOperation(this.s.topology, createCollectionOperation, callback);\n});\n/**\n * Get all the db statistics.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {number} [options.scale] Divide the returned sizes by scale value.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The collection result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nDb.prototype.stats = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Build command object\n\n  const commandObject = {\n    dbStats: true\n  }; // Check if we have the scale value\n\n  if (options['scale'] != null) commandObject['scale'] = options['scale']; // If we have a readPreference set\n\n  if (options.readPreference == null && this.s.readPreference) {\n    options.readPreference = this.s.readPreference;\n  }\n\n  const statsOperation = new CommandOperation(this, options, null, commandObject); // Execute the command\n\n  return executeOperation(this.s.topology, statsOperation, callback);\n};\n/**\n * Get the list of all collection information for the specified db.\n *\n * @method\n * @param {object} [filter={}] Query to filter collections by\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.nameOnly=false] Since 4.0: If true, will only return the collection name in the response, and will omit additional info\n * @param {number} [options.batchSize=1000] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @return {CommandCursor}\n */\n\n\nDb.prototype.listCollections = function (filter, options) {\n  filter = filter || {};\n  options = options || {};\n  return new CommandCursor(this.s.topology, new ListCollectionsOperation(this, filter, options), options);\n};\n/**\n * Evaluate JavaScript on the server\n *\n * @method\n * @param {Code} code JavaScript to execute on server.\n * @param {(object|array)} parameters The parameters for the call.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.nolock=false] Tell MongoDB not to block on the evaluation of the javascript.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The results callback\n * @deprecated Eval is deprecated on MongoDB 3.2 and forward\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.eval = deprecate(function (code, parameters, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  parameters = args.length ? args.shift() : parameters;\n  options = args.length ? args.shift() || {} : {};\n  return executeLegacyOperation(this.s.topology, evaluate, [this, code, parameters, options, callback]);\n}, 'Db.eval is deprecated as of MongoDB version 3.2');\n/**\n * Rename a collection.\n *\n * @method\n * @param {string} fromCollection Name of current collection to rename.\n * @param {string} toCollection New name of of the collection.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.dropTarget=false] Drop the target name collection if it previously exists.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~collectionResultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nDb.prototype.renameCollection = function (fromCollection, toCollection, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = Object.assign({}, options, {\n    readPreference: ReadPreference.PRIMARY\n  }); // Add return new collection\n\n  options.new_collection = true;\n  const renameOperation = new RenameOperation(this.collection(fromCollection), toCollection, options);\n  return executeOperation(this.s.topology, renameOperation, callback);\n};\n/**\n * Drop a collection from the database, removing it permanently. New accesses will create a new collection.\n *\n * @method\n * @param {string} name Name of collection to drop\n * @param {Object} [options] Optional settings\n * @param {WriteConcern} [options.writeConcern] A full WriteConcern object\n * @param {(number|string)} [options.w] The write concern\n * @param {number} [options.wtimeout] The write concern timeout\n * @param {boolean} [options.j] The journal write concern\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.dropCollection = function (name, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const dropCollectionOperation = new DropCollectionOperation(this, name, options);\n  return executeOperation(this.s.topology, dropCollectionOperation, callback);\n};\n/**\n * Drop a database, removing it permanently from the server.\n *\n * @method\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.dropDatabase = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const dropDatabaseOperation = new DropDatabaseOperation(this, options);\n  return executeOperation(this.s.topology, dropDatabaseOperation, callback);\n};\n/**\n * Fetch all collections for the current db.\n *\n * @method\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~collectionsResultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.collections = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const collectionsOperation = new CollectionsOperation(this, options);\n  return executeOperation(this.s.topology, collectionsOperation, callback);\n};\n/**\n * Runs a command on the database as admin.\n * @method\n * @param {object} command The command hash\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.executeDbAdminCommand = function (selector, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  options.readPreference = ReadPreference.resolve(this, options);\n  const executeDbAdminCommandOperation = new ExecuteDbAdminCommandOperation(this, selector, options);\n  return executeOperation(this.s.topology, executeDbAdminCommandOperation, callback);\n};\n/**\n * Creates an index on the db and collection.\n * @method\n * @param {string} name Name of the collection to create the index on.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] The write concern.\n * @param {number} [options.wtimeout] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.unique=false] Creates an unique index.\n * @param {boolean} [options.sparse=false] Creates a sparse index.\n * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.\n * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n * @param {number} [options.min] For geospatial indexes set the lower bound for the co-ordinates.\n * @param {number} [options.max] For geospatial indexes set the high bound for the co-ordinates.\n * @param {number} [options.v] Specify the format version of the indexes.\n * @param {number} [options.expireAfterSeconds] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n * @param {string} [options.name] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * @param {object} [options.partialFilterExpression] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {(number|string)} [options.commitQuorum] (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes.\n * @param {Db~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.createIndex = function (name, fieldOrSpec, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options ? Object.assign({}, options) : {};\n  const createIndexesOperation = new CreateIndexesOperation(this, name, fieldOrSpec, options);\n  return executeOperation(this.s.topology, createIndexesOperation, callback);\n};\n/**\n * Ensures that an index exists, if it does not it creates it\n * @method\n * @deprecated since version 2.0\n * @param {string} name The index name\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] The write concern.\n * @param {number} [options.wtimeout] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.unique=false] Creates an unique index.\n * @param {boolean} [options.sparse=false] Creates a sparse index.\n * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.\n * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n * @param {number} [options.min] For geospatial indexes set the lower bound for the co-ordinates.\n * @param {number} [options.max] For geospatial indexes set the high bound for the co-ordinates.\n * @param {number} [options.v] Specify the format version of the indexes.\n * @param {number} [options.expireAfterSeconds] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n * @param {number} [options.name] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.ensureIndex = deprecate(function (name, fieldOrSpec, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeLegacyOperation(this.s.topology, ensureIndex, [this, name, fieldOrSpec, options, callback]);\n}, 'Db.ensureIndex is deprecated as of MongoDB version 3.0 / driver version 2.0');\n\nDb.prototype.addChild = function (db) {\n  if (this.s.parentDb) return this.s.parentDb.addChild(db);\n  this.s.children.push(db);\n};\n/**\n * Add a user to the database.\n * @method\n * @param {string} username The username.\n * @param {string} password The password.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] The write concern.\n * @param {number} [options.wtimeout] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {object} [options.customData] Custom data associated with the user (only Mongodb 2.6 or higher)\n * @param {object[]} [options.roles] Roles associated with the created user (only Mongodb 2.6 or higher)\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.addUser = function (username, password, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Special case where there is no password ($external users)\n\n  if (typeof username === 'string' && password != null && typeof password === 'object') {\n    options = password;\n    password = null;\n  }\n\n  const addUserOperation = new AddUserOperation(this, username, password, options);\n  return executeOperation(this.s.topology, addUserOperation, callback);\n};\n/**\n * Remove a user from a database\n * @method\n * @param {string} username The username.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] The write concern.\n * @param {number} [options.wtimeout] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.removeUser = function (username, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const removeUserOperation = new RemoveUserOperation(this, username, options);\n  return executeOperation(this.s.topology, removeUserOperation, callback);\n};\n/**\n * Set the current profiling level of MongoDB\n *\n * @param {string} level The new profiling level (off, slow_only, all).\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.setProfilingLevel = function (level, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const setProfilingLevelOperation = new SetProfilingLevelOperation(this, level, options);\n  return executeOperation(this.s.topology, setProfilingLevelOperation, callback);\n};\n/**\n * Retrieve the current profiling information for MongoDB\n *\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed\n * @deprecated Query the system.profile collection directly.\n */\n\n\nDb.prototype.profilingInfo = deprecate(function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeLegacyOperation(this.s.topology, profilingInfo, [this, options, callback]);\n}, 'Db.profilingInfo is deprecated. Query the system.profile collection directly.');\n/**\n * Retrieve the current profiling Level for MongoDB\n *\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nDb.prototype.profilingLevel = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const profilingLevelOperation = new ProfilingLevelOperation(this, options);\n  return executeOperation(this.s.topology, profilingLevelOperation, callback);\n};\n/**\n * Retrieves this collections index info.\n * @method\n * @param {string} name The name of the collection.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.full=false] Returns the full raw index information.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Db~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nDb.prototype.indexInformation = function (name, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const indexInformationOperation = new IndexInformationOperation(this, name, options);\n  return executeOperation(this.s.topology, indexInformationOperation, callback);\n};\n/**\n * Unref all sockets\n * @method\n */\n\n\nDb.prototype.unref = function () {\n  this.s.topology.unref();\n};\n/**\n * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this database. Will ignore all changes to system collections.\n * @method\n * @since 3.1.0\n * @param {Array} [pipeline] An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n * @param {object} [options] Optional settings\n * @param {string} [options.fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.\n * @param {object} [options.resumeAfter] Specifies the logical starting point for the new change stream. This should be the _id field from a previously returned change stream document.\n * @param {number} [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query\n * @param {number} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {object} [options.collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {ReadPreference} [options.readPreference] The read preference. Defaults to the read preference of the database. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.\n * @param {Timestamp} [options.startAtOperationTime] receive change events that occur after the specified timestamp\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @return {ChangeStream} a ChangeStream instance.\n */\n\n\nDb.prototype.watch = function (pipeline, options) {\n  pipeline = pipeline || [];\n  options = options || {}; // Allow optionally not specifying a pipeline\n\n  if (!Array.isArray(pipeline)) {\n    options = pipeline;\n    pipeline = [];\n  }\n\n  return new ChangeStream(this, pipeline, options);\n};\n/**\n * Return the db logger\n * @method\n * @return {Logger} return the db logger\n * @ignore\n */\n\n\nDb.prototype.getLogger = function () {\n  return this.s.logger;\n};\n/**\n * Db close event\n *\n * Emitted after a socket closed against a single server or mongos proxy.\n *\n * @event Db#close\n * @type {MongoError}\n */\n\n/**\n * Db reconnect event\n *\n *  * Server: Emitted when the driver has reconnected and re-authenticated.\n *  * ReplicaSet: N/A\n *  * Mongos: Emitted when the driver reconnects and re-authenticates successfully against a Mongos.\n *\n * @event Db#reconnect\n * @type {object}\n */\n\n/**\n * Db error event\n *\n * Emitted after an error occurred against a single server or mongos proxy.\n *\n * @event Db#error\n * @type {MongoError}\n */\n\n/**\n * Db timeout event\n *\n * Emitted after a socket timeout occurred against a single server or mongos proxy.\n *\n * @event Db#timeout\n * @type {MongoError}\n */\n\n/**\n * Db parseError event\n *\n * The parseError event is emitted if the driver detects illegal or corrupt BSON being received from the server.\n *\n * @event Db#parseError\n * @type {MongoError}\n */\n\n/**\n * Db fullsetup event, emitted when all servers in the topology have been connected to at start up time.\n *\n * * Server: Emitted when the driver has connected to the single server and has authenticated.\n * * ReplSet: Emitted after the driver has attempted to connect to all replicaset members.\n * * Mongos: Emitted after the driver has attempted to connect to all mongos proxies.\n *\n * @event Db#fullsetup\n * @type {Db}\n */\n// Constants\n\n\nDb.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;\nDb.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;\nDb.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;\nDb.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;\nDb.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;\nDb.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;\nmodule.exports = Db;","map":null,"metadata":{},"sourceType":"script"}