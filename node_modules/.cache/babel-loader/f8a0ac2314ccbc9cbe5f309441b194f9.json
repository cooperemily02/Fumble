{"ast":null,"code":"'use strict';\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst Code = require('../core').BSON.Code;\n\nconst createIndexDb = require('./db_ops').createIndex;\n\nconst decorateWithCollation = require('../utils').decorateWithCollation;\n\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\n\nconst ensureIndexDb = require('./db_ops').ensureIndex;\n\nconst evaluate = require('./db_ops').evaluate;\n\nconst executeCommand = require('./db_ops').executeCommand;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst indexInformationDb = require('./db_ops').indexInformation;\n\nconst Long = require('../core').BSON.Long;\n\nconst MongoError = require('../core').MongoError;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst insertDocuments = require('./common_functions').insertDocuments;\n\nconst updateDocuments = require('./common_functions').updateDocuments;\n/**\n * Group function helper\n * @ignore\n */\n// var groupFunction = function () {\n//   var c = db[ns].find(condition);\n//   var map = new Map();\n//   var reduce_function = reduce;\n//\n//   while (c.hasNext()) {\n//     var obj = c.next();\n//     var key = {};\n//\n//     for (var i = 0, len = keys.length; i < len; ++i) {\n//       var k = keys[i];\n//       key[k] = obj[k];\n//     }\n//\n//     var aggObj = map.get(key);\n//\n//     if (aggObj == null) {\n//       var newObj = Object.extend({}, key);\n//       aggObj = Object.extend(newObj, initial);\n//       map.put(key, aggObj);\n//     }\n//\n//     reduce_function(obj, aggObj);\n//   }\n//\n//   return { \"result\": map.values() };\n// }.toString();\n\n\nconst groupFunction = 'function () {\\nvar c = db[ns].find(condition);\\nvar map = new Map();\\nvar reduce_function = reduce;\\n\\nwhile (c.hasNext()) {\\nvar obj = c.next();\\nvar key = {};\\n\\nfor (var i = 0, len = keys.length; i < len; ++i) {\\nvar k = keys[i];\\nkey[k] = obj[k];\\n}\\n\\nvar aggObj = map.get(key);\\n\\nif (aggObj == null) {\\nvar newObj = Object.extend({}, key);\\naggObj = Object.extend(newObj, initial);\\nmap.put(key, aggObj);\\n}\\n\\nreduce_function(obj, aggObj);\\n}\\n\\nreturn { \"result\": map.values() };\\n}';\n/**\n * Create an index on the db and collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Collection.prototype.createIndex for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\nfunction createIndex(coll, fieldOrSpec, options, callback) {\n  createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);\n}\n/**\n * Create multiple indexes in the collection. This method is only supported for\n * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {array} indexSpecs An array of index specifications to be created\n * @param {Object} [options] Optional settings. See Collection.prototype.createIndexes for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction createIndexes(coll, indexSpecs, options, callback) {\n  const capabilities = coll.s.topology.capabilities(); // Ensure we generate the correct name if the parameter is not set\n\n  for (let i = 0; i < indexSpecs.length; i++) {\n    if (indexSpecs[i].name == null) {\n      const keys = []; // Did the user pass in a collation, check if our write server supports it\n\n      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {\n        return callback(new MongoError('server/primary/mongos does not support collation'));\n      }\n\n      for (let name in indexSpecs[i].key) {\n        keys.push(`${name}_${indexSpecs[i].key[name]}`);\n      } // Set the name\n\n\n      indexSpecs[i].name = keys.join('_');\n    }\n  }\n\n  options = Object.assign({}, options, {\n    readPreference: ReadPreference.PRIMARY\n  }); // Execute the index\n\n  executeCommand(coll.s.db, {\n    createIndexes: coll.collectionName,\n    indexes: indexSpecs\n  }, options, callback);\n}\n/**\n * Ensure that an index exists. If the index does not exist, this function creates it.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Collection.prototype.ensureIndex for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction ensureIndex(coll, fieldOrSpec, options, callback) {\n  ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);\n}\n/**\n * Run a group command across a collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.\n * @param {object} condition An optional condition that must be true for a row to be considered.\n * @param {object} initial Initial value of the aggregation counter object.\n * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated\n * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.\n * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.\n * @param {object} [options] Optional settings. See Collection.prototype.group for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @deprecated MongoDB 3.6 or higher will no longer support the group command. We recommend rewriting using the aggregation framework.\n */\n\n\nfunction group(coll, keys, condition, initial, reduce, finalize, command, options, callback) {\n  // Execute using the command\n  if (command) {\n    const reduceFunction = reduce && reduce._bsontype === 'Code' ? reduce : new Code(reduce);\n    const selector = {\n      group: {\n        ns: coll.collectionName,\n        $reduce: reduceFunction,\n        cond: condition,\n        initial: initial,\n        out: 'inline'\n      }\n    }; // if finalize is defined\n\n    if (finalize != null) selector.group['finalize'] = finalize; // Set up group selector\n\n    if ('function' === typeof keys || keys && keys._bsontype === 'Code') {\n      selector.group.$keyf = keys && keys._bsontype === 'Code' ? keys : new Code(keys);\n    } else {\n      const hash = {};\n      keys.forEach(key => {\n        hash[key] = 1;\n      });\n      selector.group.key = hash;\n    }\n\n    options = Object.assign({}, options); // Ensure we have the right read preference inheritance\n\n    options.readPreference = ReadPreference.resolve(coll, options); // Do we have a readConcern specified\n\n    decorateWithReadConcern(selector, coll, options); // Have we specified collation\n\n    try {\n      decorateWithCollation(selector, coll, options);\n    } catch (err) {\n      return callback(err, null);\n    } // Execute command\n\n\n    executeCommand(coll.s.db, selector, options, (err, result) => {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, result.retval);\n    });\n  } else {\n    // Create execution scope\n    const scope = reduce != null && reduce._bsontype === 'Code' ? reduce.scope : {};\n    scope.ns = coll.collectionName;\n    scope.keys = keys;\n    scope.condition = condition;\n    scope.initial = initial; // Pass in the function text to execute within mongodb.\n\n    const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');\n    evaluate(coll.s.db, new Code(groupfn, scope), null, options, (err, results) => {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, results.result || results);\n    });\n  }\n}\n/**\n * Retrieve all the indexes on the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {Object} [options] Optional settings. See Collection.prototype.indexes for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexes(coll, options, callback) {\n  options = Object.assign({}, {\n    full: true\n  }, options);\n  indexInformationDb(coll.s.db, coll.collectionName, options, callback);\n}\n/**\n * Check if one or more indexes exist on the collection. This fails on the first index that doesn't exist.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|array)} indexes One or more index names to check.\n * @param {Object} [options] Optional settings. See Collection.prototype.indexExists for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexExists(coll, indexes, options, callback) {\n  indexInformation(coll, options, (err, indexInformation) => {\n    // If we have an error return\n    if (err != null) return handleCallback(callback, err, null); // Let's check for the index names\n\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, indexInformation[indexes] != null); // Check in list of indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexInformation[indexes[i]] == null) {\n        return handleCallback(callback, null, false);\n      }\n    } // All keys found return true\n\n\n    return handleCallback(callback, null, true);\n  });\n}\n/**\n * Retrieve this collection's index info.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} [options] Optional settings. See Collection.prototype.indexInformation for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexInformation(coll, options, callback) {\n  indexInformationDb(coll.s.db, coll.collectionName, options, callback);\n}\n/**\n * Return N parallel cursors for a collection to allow parallel reading of the entire collection. There are\n * no ordering guarantees for returned results.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} [options] Optional settings. See Collection.prototype.parallelCollectionScan for a list of options.\n * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback\n */\n\n\nfunction parallelCollectionScan(coll, options, callback) {\n  // Create command object\n  const commandObject = {\n    parallelCollectionScan: coll.collectionName,\n    numCursors: options.numCursors\n  }; // Do we have a readConcern specified\n\n  decorateWithReadConcern(commandObject, coll, options); // Store the raw value\n\n  const raw = options.raw;\n  delete options['raw']; // Execute the command\n\n  executeCommand(coll.s.db, commandObject, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, new Error('no result returned for parallelCollectionScan'), null);\n    options = Object.assign({\n      explicitlyIgnoreSession: true\n    }, options);\n    const cursors = []; // Add the raw back to the option\n\n    if (raw) options.raw = raw; // Create command cursors for each item\n\n    for (let i = 0; i < result.cursors.length; i++) {\n      const rawId = result.cursors[i].cursor.id; // Convert cursorId to Long if needed\n\n      const cursorId = typeof rawId === 'number' ? Long.fromNumber(rawId) : rawId; // Add a command cursor\n\n      cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options));\n    }\n\n    handleCallback(callback, null, cursors);\n  });\n}\n/**\n * Save a document.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} doc Document to save\n * @param {object} [options] Optional settings. See Collection.prototype.save for a list of options.\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @deprecated use insertOne, insertMany, updateOne or updateMany\n */\n\n\nfunction save(coll, doc, options, callback) {\n  // Get the write concern options\n  const finalOptions = applyWriteConcern(Object.assign({}, options), {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Establish if we need to perform an insert or update\n\n  if (doc._id != null) {\n    finalOptions.upsert = true;\n    return updateDocuments(coll, {\n      _id: doc._id\n    }, doc, finalOptions, callback);\n  } // Insert the document\n\n\n  insertDocuments(coll, [doc], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (doc == null) return handleCallback(callback, null, null);\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result);\n  });\n}\n\nmodule.exports = {\n  createIndex,\n  createIndexes,\n  ensureIndex,\n  group,\n  indexes,\n  indexExists,\n  indexInformation,\n  parallelCollectionScan,\n  save\n};","map":null,"metadata":{},"sourceType":"script"}