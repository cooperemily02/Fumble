{"ast":null,"code":"'use strict';\n\nvar Binary = require('../core').BSON.Binary,\n    ObjectID = require('../core').BSON.ObjectID;\n\nvar Buffer = require('safe-buffer').Buffer;\n/**\n * Class for representing a single chunk in GridFS.\n *\n * @class\n *\n * @param file {GridStore} The {@link GridStore} object holding this chunk.\n * @param mongoObject {object} The mongo object representation of this chunk.\n *\n * @throws Error when the type of data field for {@link mongoObject} is not\n *     supported. Currently supported types for data field are instances of\n *     {@link String}, {@link Array}, {@link Binary} and {@link Binary}\n *     from the bson module\n *\n * @see Chunk#buildMongoObject\n */\n\n\nvar Chunk = function (file, mongoObject, writeConcern) {\n  if (!(this instanceof Chunk)) return new Chunk(file, mongoObject);\n  this.file = file;\n  var mongoObjectFinal = mongoObject == null ? {} : mongoObject;\n  this.writeConcern = writeConcern || {\n    w: 1\n  };\n  this.objectId = mongoObjectFinal._id == null ? new ObjectID() : mongoObjectFinal._id;\n  this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;\n  this.data = new Binary();\n\n  if (typeof mongoObjectFinal.data === 'string') {\n    var buffer = Buffer.alloc(mongoObjectFinal.data.length);\n    buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, 'binary');\n    this.data = new Binary(buffer);\n  } else if (Array.isArray(mongoObjectFinal.data)) {\n    buffer = Buffer.alloc(mongoObjectFinal.data.length);\n    var data = mongoObjectFinal.data.join('');\n    buffer.write(data, 0, data.length, 'binary');\n    this.data = new Binary(buffer);\n  } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === 'Binary') {\n    this.data = mongoObjectFinal.data;\n  } else if (!Buffer.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {\n    throw Error('Illegal chunk format');\n  } // Update position\n\n\n  this.internalPosition = 0;\n};\n/**\n * Writes a data to this object and advance the read/write head.\n *\n * @param data {string} the data to write\n * @param callback {function(*, GridStore)} This will be called after executing\n *     this method. The first parameter will contain null and the second one\n *     will contain a reference to this object.\n */\n\n\nChunk.prototype.write = function (data, callback) {\n  this.data.write(data, this.internalPosition, data.length, 'binary');\n  this.internalPosition = this.data.length();\n  if (callback != null) return callback(null, this);\n  return this;\n};\n/**\n * Reads data and advances the read/write head.\n *\n * @param length {number} The length of data to read.\n *\n * @return {string} The data read if the given length will not exceed the end of\n *     the chunk. Returns an empty String otherwise.\n */\n\n\nChunk.prototype.read = function (length) {\n  // Default to full read if no index defined\n  length = length == null || length === 0 ? this.length() : length;\n\n  if (this.length() - this.internalPosition + 1 >= length) {\n    var data = this.data.read(this.internalPosition, length);\n    this.internalPosition = this.internalPosition + length;\n    return data;\n  } else {\n    return '';\n  }\n};\n\nChunk.prototype.readSlice = function (length) {\n  if (this.length() - this.internalPosition >= length) {\n    var data = null;\n\n    if (this.data.buffer != null) {\n      //Pure BSON\n      data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);\n    } else {\n      //Native BSON\n      data = Buffer.alloc(length);\n      length = this.data.readInto(data, this.internalPosition);\n    }\n\n    this.internalPosition = this.internalPosition + length;\n    return data;\n  } else {\n    return null;\n  }\n};\n/**\n * Checks if the read/write head is at the end.\n *\n * @return {boolean} Whether the read/write head has reached the end of this\n *     chunk.\n */\n\n\nChunk.prototype.eof = function () {\n  return this.internalPosition === this.length() ? true : false;\n};\n/**\n * Reads one character from the data of this chunk and advances the read/write\n * head.\n *\n * @return {string} a single character data read if the the read/write head is\n *     not at the end of the chunk. Returns an empty String otherwise.\n */\n\n\nChunk.prototype.getc = function () {\n  return this.read(1);\n};\n/**\n * Clears the contents of the data in this chunk and resets the read/write head\n * to the initial position.\n */\n\n\nChunk.prototype.rewind = function () {\n  this.internalPosition = 0;\n  this.data = new Binary();\n};\n/**\n * Saves this chunk to the database. Also overwrites existing entries having the\n * same id as this chunk.\n *\n * @param callback {function(*, GridStore)} This will be called after executing\n *     this method. The first parameter will contain null and the second one\n *     will contain a reference to this object.\n */\n\n\nChunk.prototype.save = function (options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  self.file.chunkCollection(function (err, collection) {\n    if (err) return callback(err); // Merge the options\n\n    var writeOptions = {\n      upsert: true\n    };\n\n    for (var name in options) writeOptions[name] = options[name];\n\n    for (name in self.writeConcern) writeOptions[name] = self.writeConcern[name];\n\n    if (self.data.length() > 0) {\n      self.buildMongoObject(function (mongoObject) {\n        var options = {\n          forceServerObjectId: true\n        };\n\n        for (var name in self.writeConcern) {\n          options[name] = self.writeConcern[name];\n        }\n\n        collection.replaceOne({\n          _id: self.objectId\n        }, mongoObject, writeOptions, function (err) {\n          callback(err, self);\n        });\n      });\n    } else {\n      callback(null, self);\n    } // });\n\n  });\n};\n/**\n * Creates a mongoDB object representation of this chunk.\n *\n * @param callback {function(Object)} This will be called after executing this\n *     method. The object will be passed to the first parameter and will have\n *     the structure:\n *\n *        <pre><code>\n *        {\n *          '_id' : , // {number} id for this chunk\n *          'files_id' : , // {number} foreign key to the file collection\n *          'n' : , // {number} chunk number\n *          'data' : , // {bson#Binary} the chunk data itself\n *        }\n *        </code></pre>\n *\n * @see <a href=\"http://www.mongodb.org/display/DOCS/GridFS+Specification#GridFSSpecification-{{chunks}}\">MongoDB GridFS Chunk Object Structure</a>\n */\n\n\nChunk.prototype.buildMongoObject = function (callback) {\n  var mongoObject = {\n    files_id: this.file.fileId,\n    n: this.chunkNumber,\n    data: this.data\n  }; // If we are saving using a specific ObjectId\n\n  if (this.objectId != null) mongoObject._id = this.objectId;\n  callback(mongoObject);\n};\n/**\n * @return {number} the length of the data\n */\n\n\nChunk.prototype.length = function () {\n  return this.data.length();\n};\n/**\n * The position of the read/write head\n * @name position\n * @lends Chunk#\n * @field\n */\n\n\nObject.defineProperty(Chunk.prototype, 'position', {\n  enumerable: true,\n  get: function () {\n    return this.internalPosition;\n  },\n  set: function (value) {\n    this.internalPosition = value;\n  }\n});\n/**\n * The default chunk size\n * @constant\n */\n\nChunk.DEFAULT_CHUNK_SIZE = 1024 * 255;\nmodule.exports = Chunk;","map":null,"metadata":{},"sourceType":"script"}