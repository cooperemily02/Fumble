{"ast":null,"code":"function ConfettiGenerator(params) {\n  //////////////\n  // Defaults\n  var appstate = {\n    target: 'confetti-holder',\n    // Id of the canvas\n    max: 80,\n    // Max itens to render\n    size: 1,\n    // prop size\n    animate: true,\n    // Should animate?\n    respawn: true,\n    // Should confettis be respawned when getting out of screen?\n    props: ['circle', 'square', 'triangle', 'line'],\n    // Types of confetti\n    colors: [[165, 104, 246], [230, 61, 135], [0, 199, 228], [253, 214, 126]],\n    // Colors to render confetti\n    clock: 25,\n    // Speed of confetti fall\n    interval: null,\n    // Draw interval holder\n    rotate: false,\n    // Whenever to rotate a prop\n    start_from_edge: false,\n    // Should confettis spawn at the top/bottom of the screen?\n    width: window.innerWidth,\n    // canvas width (as int, in px)\n    height: window.innerHeight // canvas height (as int, in px)\n\n  }; //////////////\n  // Setting parameters if received\n\n  if (params) {\n    if (params.target) appstate.target = params.target;\n    if (params.max) appstate.max = params.max;\n    if (params.size) appstate.size = params.size;\n    if (params.animate !== undefined && params.animate !== null) appstate.animate = params.animate;\n    if (params.respawn !== undefined && params.respawn !== null) appstate.respawn = params.respawn;\n    if (params.props) appstate.props = params.props;\n    if (params.colors) appstate.colors = params.colors;\n    if (params.clock) appstate.clock = params.clock;\n    if (params.start_from_edge !== undefined && params.start_from_edge !== null) appstate.start_from_edge = params.start_from_edge;\n    if (params.width) appstate.width = params.width;\n    if (params.height) appstate.height = params.height;\n    if (params.rotate !== undefined && params.rotate !== null) appstate.rotate = params.rotate;\n  } //////////////\n  // Early exit if the target is not the correct type, or is null\n\n\n  if (typeof appstate.target != 'object' && typeof appstate.target != 'string') {\n    throw new TypeError('The target parameter should be a node or string');\n  }\n\n  if (typeof appstate.target == 'object' && (appstate.target === null || !appstate.target instanceof HTMLCanvasElement) || typeof appstate.target == 'string' && (document.getElementById(appstate.target) === null || !document.getElementById(appstate.target) instanceof HTMLCanvasElement)) {\n    throw new ReferenceError('The target element does not exist or is not a canvas element');\n  } //////////////\n  // Properties\n\n\n  var cv = typeof appstate.target == 'object' ? appstate.target : document.getElementById(appstate.target);\n  var ctx = cv.getContext(\"2d\");\n  var particles = []; //////////////\n  // Random helper (to minimize typing)\n\n  function rand(limit, floor) {\n    if (!limit) limit = 1;\n    var rand = Math.random() * limit;\n    return !floor ? rand : Math.floor(rand);\n  }\n\n  var totalWeight = appstate.props.reduce(function (weight, prop) {\n    return weight + (prop.weight || 1);\n  }, 0);\n\n  function selectProp() {\n    var rand = Math.random() * totalWeight;\n\n    for (var i = 0; i < appstate.props.length; ++i) {\n      var weight = appstate.props[i].weight || 1;\n      if (rand < weight) return i;\n      rand -= weight;\n    }\n  } //////////////\n  // Confetti particle generator\n\n\n  function particleFactory() {\n    var prop = appstate.props[selectProp()];\n    var p = {\n      prop: prop.type ? prop.type : prop,\n      //prop type\n      x: rand(appstate.width),\n      //x-coordinate\n      y: appstate.start_from_edge ? appstate.clock >= 0 ? -10 : parseFloat(appstate.height) + 10 : rand(appstate.height),\n      //y-coordinate\n      src: prop.src,\n      radius: rand(4) + 1,\n      //radius\n      size: prop.size,\n      rotate: appstate.rotate,\n      line: Math.floor(rand(65) - 30),\n      // line angle\n      angles: [rand(10, true) + 2, rand(10, true) + 2, rand(10, true) + 2, rand(10, true) + 2],\n      // triangle drawing angles\n      color: appstate.colors[rand(appstate.colors.length, true)],\n      // color\n      rotation: rand(360, true) * Math.PI / 180,\n      speed: rand(appstate.clock / 7) + appstate.clock / 30\n    };\n    return p;\n  } //////////////\n  // Confetti drawing on canvas\n\n\n  function particleDraw(p) {\n    if (!p) {\n      return;\n    }\n\n    var op = p.radius <= 3 ? 0.4 : 0.8;\n    ctx.fillStyle = ctx.strokeStyle = \"rgba(\" + p.color + \", \" + op + \")\";\n    ctx.beginPath();\n\n    switch (p.prop) {\n      case 'circle':\n        {\n          ctx.moveTo(p.x, p.y);\n          ctx.arc(p.x, p.y, p.radius * appstate.size, 0, Math.PI * 2, true);\n          ctx.fill();\n          break;\n        }\n\n      case 'triangle':\n        {\n          ctx.moveTo(p.x, p.y);\n          ctx.lineTo(p.x + p.angles[0] * appstate.size, p.y + p.angles[1] * appstate.size);\n          ctx.lineTo(p.x + p.angles[2] * appstate.size, p.y + p.angles[3] * appstate.size);\n          ctx.closePath();\n          ctx.fill();\n          break;\n        }\n\n      case 'line':\n        {\n          ctx.moveTo(p.x, p.y);\n          ctx.lineTo(p.x + p.line * appstate.size, p.y + p.radius * 5);\n          ctx.lineWidth = 2 * appstate.size;\n          ctx.stroke();\n          break;\n        }\n\n      case 'square':\n        {\n          ctx.save();\n          ctx.translate(p.x + 15, p.y + 5);\n          ctx.rotate(p.rotation);\n          ctx.fillRect(-15 * appstate.size, -5 * appstate.size, 15 * appstate.size, 5 * appstate.size);\n          ctx.restore();\n          break;\n        }\n\n      case 'svg':\n        {\n          ctx.save();\n          var image = new window.Image();\n          image.src = p.src;\n          var size = p.size || 15;\n          ctx.translate(p.x + size / 2, p.y + size / 2);\n          if (p.rotate) ctx.rotate(p.rotation);\n          ctx.drawImage(image, -(size / 2) * appstate.size, -(size / 2) * appstate.size, size * appstate.size, size * appstate.size);\n          ctx.restore();\n          break;\n        }\n    }\n  } //////////////\n  // Public itens\n  //////////////\n  //////////////\n  // Clean actual state\n\n\n  var _clear = function () {\n    appstate.animate = false;\n    clearInterval(appstate.interval);\n    requestAnimationFrame(function () {\n      ctx.clearRect(0, 0, cv.width, cv.height);\n      var w = cv.width;\n      cv.width = 1;\n      cv.width = w;\n    });\n  }; //////////////\n  // Render confetti on canvas\n\n\n  var _render = function () {\n    cv.width = appstate.width;\n    cv.height = appstate.height;\n    particles = [];\n\n    for (var i = 0; i < appstate.max; i++) particles.push(particleFactory());\n\n    function draw() {\n      ctx.clearRect(0, 0, appstate.width, appstate.height);\n\n      for (var i in particles) particleDraw(particles[i]);\n\n      update();\n      if (appstate.animate) requestAnimationFrame(draw);\n    }\n\n    function update() {\n      for (var i = 0; i < appstate.max; i++) {\n        var p = particles[i];\n\n        if (p) {\n          if (appstate.animate) p.y += p.speed;\n          if (p.rotate) p.rotation += p.speed / 35;\n\n          if (p.speed >= 0 && p.y > appstate.height || p.speed < 0 && p.y < 0) {\n            if (appstate.respawn) {\n              particles[i] = p;\n              particles[i].x = rand(appstate.width, true);\n              particles[i].y = p.speed >= 0 ? -10 : parseFloat(appstate.height);\n            } else {\n              particles[i] = undefined;\n            }\n          }\n        }\n      }\n\n      if (particles.every(function (p) {\n        return p === undefined;\n      })) {\n        _clear();\n      }\n    }\n\n    return requestAnimationFrame(draw);\n  };\n\n  return {\n    render: _render,\n    clear: _clear\n  };\n}\n\nexport default ConfettiGenerator;","map":null,"metadata":{},"sourceType":"module"}