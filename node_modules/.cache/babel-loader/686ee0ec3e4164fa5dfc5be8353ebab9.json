{"ast":null,"code":"'use strict';\n\nconst Aspect = require('./operation').Aspect;\n\nconst defineAspects = require('./operation').defineAspects;\n\nconst CommandOperationV2 = require('./command_v2');\n\nconst MongoError = require('../core').MongoError;\n\nconst parseIndexOptions = require('../utils').parseIndexOptions;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'expireAfterSeconds', 'storageEngine', 'collation', // text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion', // 2d-sphere indexes\n'2dsphereIndexVersion', // 2d indexes\n'bits', 'min', 'max', // geoHaystack Indexes\n'bucketSize', // wildcard indexes\n'wildcardProjection']);\n\nclass CreateIndexesOperation extends CommandOperationV2 {\n  /**\n   * @ignore\n   */\n  constructor(parent, collection, indexes, options) {\n    super(parent, options);\n    this.collection = collection; // createIndex can be called with a variety of styles:\n    //   coll.createIndex('a');\n    //   coll.createIndex({ a: 1 });\n    //   coll.createIndex([['a', 1]]);\n    // createIndexes is always called with an array of index spec objects\n\n    if (!Array.isArray(indexes) || Array.isArray(indexes[0])) {\n      this.onlyReturnNameOfCreatedIndex = true; // TODO: remove in v4 (breaking change); make createIndex return full response as createIndexes does\n\n      const indexParameters = parseIndexOptions(indexes); // Generate the index name\n\n      const name = typeof options.name === 'string' ? options.name : indexParameters.name; // Set up the index\n\n      const indexSpec = {\n        name,\n        key: indexParameters.fieldHash\n      }; // merge valid index options into the index spec\n\n      for (let optionName in options) {\n        if (VALID_INDEX_OPTIONS.has(optionName)) {\n          indexSpec[optionName] = options[optionName];\n        }\n      }\n\n      this.indexes = [indexSpec];\n      return;\n    }\n\n    this.indexes = indexes;\n  }\n  /**\n   * @ignore\n   */\n\n\n  execute(server, callback) {\n    const options = this.options;\n    const indexes = this.indexes;\n    const serverWireVersion = maxWireVersion(server); // Ensure we generate the correct name if the parameter is not set\n\n    for (let i = 0; i < indexes.length; i++) {\n      // Did the user pass in a collation, check if our write server supports it\n      if (indexes[i].collation && serverWireVersion < 5) {\n        callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));\n        return;\n      }\n\n      if (indexes[i].name == null) {\n        const keys = [];\n\n        for (let name in indexes[i].key) {\n          keys.push(`${name}_${indexes[i].key[name]}`);\n        } // Set the name\n\n\n        indexes[i].name = keys.join('_');\n      }\n    }\n\n    const cmd = {\n      createIndexes: this.collection,\n      indexes\n    };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(new MongoError('`commitQuorum` option for `createIndexes` not supported on servers < 4.4'));\n        return;\n      }\n\n      cmd.commitQuorum = options.commitQuorum;\n    } // collation is set on each index, it should not be defined at the root\n\n\n    this.options.collation = undefined;\n    super.executeCommand(server, cmd, (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      callback(null, this.onlyReturnNameOfCreatedIndex ? indexes[0].name : result);\n    });\n  }\n\n}\n\ndefineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION, Aspect.EXECUTE_WITH_SELECTION]);\nmodule.exports = CreateIndexesOperation;","map":null,"metadata":{},"sourceType":"script"}