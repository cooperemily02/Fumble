{"ast":null,"code":"'use strict';\n\nconst Aspect = require('./operation').Aspect;\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst ReadConcern = require('../read_concern');\n\nconst WriteConcern = require('../write_concern');\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst commandSupportsReadConcern = require('../core/sessions').commandSupportsReadConcern;\n\nconst MongoError = require('../core/error').MongoError;\n\nconst SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;\n\nclass CommandOperationV2 extends OperationBase {\n  constructor(parent, options, operationOptions) {\n    super(options);\n    this.ns = parent.s.namespace.withCollection('$cmd');\n    const propertyProvider = this.hasAspect(Aspect.NO_INHERIT_OPTIONS) ? undefined : parent;\n    this.readPreference = this.hasAspect(Aspect.WRITE_OPERATION) ? ReadPreference.primary : ReadPreference.resolve(propertyProvider, this.options);\n    this.readConcern = resolveReadConcern(propertyProvider, this.options);\n    this.writeConcern = resolveWriteConcern(propertyProvider, this.options);\n    this.explain = false;\n\n    if (operationOptions && typeof operationOptions.fullResponse === 'boolean') {\n      this.fullResponse = true;\n    } // TODO: A lot of our code depends on having the read preference in the options. This should\n    //       go away, but also requires massive test rewrites.\n\n\n    this.options.readPreference = this.readPreference; // TODO(NODE-2056): make logger another \"inheritable\" property\n\n    if (parent.s.logger) {\n      this.logger = parent.s.logger;\n    } else if (parent.s.db && parent.s.db.logger) {\n      this.logger = parent.s.db.logger;\n    }\n  }\n\n  executeCommand(server, cmd, callback) {\n    // TODO: consider making this a non-enumerable property\n    this.server = server;\n    const options = this.options;\n    const serverWireVersion = maxWireVersion(server);\n    const inTransaction = this.session && this.session.inTransaction();\n\n    if (this.readConcern && commandSupportsReadConcern(cmd) && !inTransaction) {\n      Object.assign(cmd, {\n        readConcern: this.readConcern\n      });\n    }\n\n    if (options.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {\n      callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));\n      return;\n    }\n\n    if (serverWireVersion >= SUPPORTS_WRITE_CONCERN_AND_COLLATION) {\n      if (this.writeConcern && this.hasAspect(Aspect.WRITE_OPERATION)) {\n        Object.assign(cmd, {\n          writeConcern: this.writeConcern\n        });\n      }\n\n      if (options.collation && typeof options.collation === 'object') {\n        Object.assign(cmd, {\n          collation: options.collation\n        });\n      }\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      cmd.maxTimeMS = options.maxTimeMS;\n    }\n\n    if (typeof options.comment === 'string') {\n      cmd.comment = options.comment;\n    }\n\n    if (this.logger && this.logger.isDebug()) {\n      this.logger.debug(`executing command ${JSON.stringify(cmd)} against ${this.ns}`);\n    }\n\n    server.command(this.ns.toString(), cmd, this.options, (err, result) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      if (this.fullResponse) {\n        callback(null, result);\n        return;\n      }\n\n      callback(null, result.result);\n    });\n  }\n\n}\n\nfunction resolveWriteConcern(parent, options) {\n  return WriteConcern.fromOptions(options) || parent && parent.writeConcern;\n}\n\nfunction resolveReadConcern(parent, options) {\n  return ReadConcern.fromOptions(options) || parent && parent.readConcern;\n}\n\nmodule.exports = CommandOperationV2;","map":null,"metadata":{},"sourceType":"script"}