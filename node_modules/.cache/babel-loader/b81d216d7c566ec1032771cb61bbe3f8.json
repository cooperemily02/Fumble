{"ast":null,"code":"'use strict';\n\nconst deprecate = require('util').deprecate;\n\nconst Logger = require('../core').Logger;\n\nconst MongoCredentials = require('../core').MongoCredentials;\n\nconst MongoError = require('../core').MongoError;\n\nconst Mongos = require('../topologies/mongos');\n\nconst NativeTopology = require('../topologies/native_topology');\n\nconst parse = require('../core').parseConnectionString;\n\nconst ReadConcern = require('../read_concern');\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst ReplSet = require('../topologies/replset');\n\nconst Server = require('../topologies/server');\n\nconst ServerSessionPool = require('../core').Sessions.ServerSessionPool;\n\nconst emitDeprecationWarning = require('../utils').emitDeprecationWarning;\n\nconst fs = require('fs');\n\nconst BSON = require('../core/connection/utils').retrieveBSON();\n\nconst CMAP_EVENT_NAMES = require('../cmap/events').CMAP_EVENT_NAMES;\n\nlet client;\n\nfunction loadClient() {\n  if (!client) {\n    client = require('../mongo_client');\n  }\n\n  return client;\n}\n\nconst legacyParse = deprecate(require('../url_parser'), 'current URL string parser is deprecated, and will be removed in a future version. ' + 'To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.');\nconst AUTH_MECHANISM_INTERNAL_MAP = {\n  DEFAULT: 'default',\n  PLAIN: 'plain',\n  GSSAPI: 'gssapi',\n  'MONGODB-CR': 'mongocr',\n  'MONGODB-X509': 'x509',\n  'MONGODB-AWS': 'mongodb-aws',\n  'SCRAM-SHA-1': 'scram-sha-1',\n  'SCRAM-SHA-256': 'scram-sha-256'\n};\nconst monitoringEvents = ['timeout', 'close', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'commandStarted', 'commandSucceeded', 'commandFailed', 'joined', 'left', 'ping', 'ha', 'all', 'fullsetup', 'open'];\nconst VALID_AUTH_MECHANISMS = new Set(['DEFAULT', 'PLAIN', 'GSSAPI', 'MONGODB-CR', 'MONGODB-X509', 'MONGODB-AWS', 'SCRAM-SHA-1', 'SCRAM-SHA-256']);\nconst validOptionNames = ['poolSize', 'ssl', 'sslValidate', 'sslCA', 'sslCert', 'sslKey', 'sslPass', 'sslCRL', 'autoReconnect', 'noDelay', 'keepAlive', 'keepAliveInitialDelay', 'connectTimeoutMS', 'family', 'socketTimeoutMS', 'reconnectTries', 'reconnectInterval', 'ha', 'haInterval', 'replicaSet', 'secondaryAcceptableLatencyMS', 'acceptableLatencyMS', 'connectWithNoPrimary', 'authSource', 'w', 'wtimeout', 'j', 'forceServerObjectId', 'serializeFunctions', 'ignoreUndefined', 'raw', 'bufferMaxEntries', 'readPreference', 'pkFactory', 'promiseLibrary', 'readConcern', 'maxStalenessSeconds', 'loggerLevel', 'logger', 'promoteValues', 'promoteBuffers', 'promoteLongs', 'domainsEnabled', 'checkServerIdentity', 'validateOptions', 'appname', 'auth', 'user', 'password', 'authMechanism', 'compression', 'fsync', 'readPreferenceTags', 'numberOfRetries', 'auto_reconnect', 'minSize', 'monitorCommands', 'retryWrites', 'retryReads', 'useNewUrlParser', 'useUnifiedTopology', 'serverSelectionTimeoutMS', 'useRecoveryToken', 'autoEncryption', 'driverInfo', 'tls', 'tlsInsecure', 'tlsinsecure', 'tlsAllowInvalidCertificates', 'tlsAllowInvalidHostnames', 'tlsCAFile', 'tlsCertificateFile', 'tlsCertificateKeyFile', 'tlsCertificateKeyFilePassword', 'minHeartbeatFrequencyMS', 'heartbeatFrequencyMS', 'directConnection', 'appName', // CMAP options\n'maxPoolSize', 'minPoolSize', 'maxIdleTimeMS', 'waitQueueTimeoutMS'];\nconst ignoreOptionNames = ['native_parser'];\nconst legacyOptionNames = ['server', 'replset', 'replSet', 'mongos', 'db']; // Validate options object\n\nfunction validOptions(options) {\n  const _validOptions = validOptionNames.concat(legacyOptionNames);\n\n  for (const name in options) {\n    if (ignoreOptionNames.indexOf(name) !== -1) {\n      continue;\n    }\n\n    if (_validOptions.indexOf(name) === -1) {\n      if (options.validateOptions) {\n        return new MongoError(`option ${name} is not supported`);\n      } else {\n        console.warn(`the options [${name}] is not supported`);\n      }\n    }\n\n    if (legacyOptionNames.indexOf(name) !== -1) {\n      console.warn(`the server/replset/mongos/db options are deprecated, ` + `all their options are supported at the top level of the options object [${validOptionNames}]`);\n    }\n  }\n}\n\nconst LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => {\n  obj[name.toLowerCase()] = name;\n  return obj;\n}, {});\n\nfunction addListeners(mongoClient, topology) {\n  topology.on('authenticated', createListener(mongoClient, 'authenticated'));\n  topology.on('error', createListener(mongoClient, 'error'));\n  topology.on('timeout', createListener(mongoClient, 'timeout'));\n  topology.on('close', createListener(mongoClient, 'close'));\n  topology.on('parseError', createListener(mongoClient, 'parseError'));\n  topology.once('open', createListener(mongoClient, 'open'));\n  topology.once('fullsetup', createListener(mongoClient, 'fullsetup'));\n  topology.once('all', createListener(mongoClient, 'all'));\n  topology.on('reconnect', createListener(mongoClient, 'reconnect'));\n}\n\nfunction assignTopology(client, topology) {\n  client.topology = topology;\n\n  if (!(topology instanceof NativeTopology)) {\n    topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);\n  }\n} // Clear out all events\n\n\nfunction clearAllEvents(topology) {\n  monitoringEvents.forEach(event => topology.removeAllListeners(event));\n} // Collect all events in order from SDAM\n\n\nfunction collectEvents(mongoClient, topology) {\n  let MongoClient = loadClient();\n  const collectedEvents = [];\n\n  if (mongoClient instanceof MongoClient) {\n    monitoringEvents.forEach(event => {\n      topology.on(event, (object1, object2) => {\n        if (event === 'open') {\n          collectedEvents.push({\n            event: event,\n            object1: mongoClient\n          });\n        } else {\n          collectedEvents.push({\n            event: event,\n            object1: object1,\n            object2: object2\n          });\n        }\n      });\n    });\n  }\n\n  return collectedEvents;\n}\n\nfunction resolveTLSOptions(options) {\n  if (options.tls == null) {\n    return;\n  }\n\n  ['sslCA', 'sslKey', 'sslCert'].forEach(optionName => {\n    if (options[optionName]) {\n      options[optionName] = fs.readFileSync(options[optionName]);\n    }\n  });\n}\n\nconst emitDeprecationForNonUnifiedTopology = deprecate(() => {}, 'current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. ' + 'To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.');\n\nfunction connect(mongoClient, url, options, callback) {\n  options = Object.assign({}, options); // If callback is null throw an exception\n\n  if (callback == null) {\n    throw new Error('no callback function provided');\n  }\n\n  let didRequestAuthentication = false;\n  const logger = Logger('MongoClient', options); // Did we pass in a Server/ReplSet/Mongos\n\n  if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {\n    return connectWithUrl(mongoClient, url, options, connectCallback);\n  }\n\n  const useNewUrlParser = options.useNewUrlParser !== false;\n  const parseFn = useNewUrlParser ? parse : legacyParse;\n  const transform = useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;\n  parseFn(url, options, (err, _object) => {\n    // Do not attempt to connect if parsing error\n    if (err) return callback(err); // Flatten\n\n    const object = transform(_object); // Parse the string\n\n    const _finalOptions = createUnifiedOptions(object, options); // Check if we have connection and socket timeout set\n\n\n    if (_finalOptions.socketTimeoutMS == null) _finalOptions.socketTimeoutMS = 0;\n    if (_finalOptions.connectTimeoutMS == null) _finalOptions.connectTimeoutMS = 10000;\n    if (_finalOptions.retryWrites == null) _finalOptions.retryWrites = true;\n    if (_finalOptions.useRecoveryToken == null) _finalOptions.useRecoveryToken = true;\n    if (_finalOptions.readPreference == null) _finalOptions.readPreference = 'primary';\n\n    if (_finalOptions.db_options && _finalOptions.db_options.auth) {\n      delete _finalOptions.db_options.auth;\n    } // `journal` should be translated to `j` for the driver\n\n\n    if (_finalOptions.journal != null) {\n      _finalOptions.j = _finalOptions.journal;\n      _finalOptions.journal = undefined;\n    } // resolve tls options if needed\n\n\n    resolveTLSOptions(_finalOptions); // Store the merged options object\n\n    mongoClient.s.options = _finalOptions; // Failure modes\n\n    if (object.servers.length === 0) {\n      return callback(new Error('connection string must contain at least one seed host'));\n    }\n\n    if (_finalOptions.auth && !_finalOptions.credentials) {\n      try {\n        didRequestAuthentication = true;\n        _finalOptions.credentials = generateCredentials(mongoClient, _finalOptions.auth.user, _finalOptions.auth.password, _finalOptions);\n      } catch (err) {\n        return callback(err);\n      }\n    }\n\n    if (_finalOptions.useUnifiedTopology) {\n      return createTopology(mongoClient, 'unified', _finalOptions, connectCallback);\n    }\n\n    emitDeprecationForNonUnifiedTopology(); // Do we have a replicaset then skip discovery and go straight to connectivity\n\n    if (_finalOptions.replicaSet || _finalOptions.rs_name) {\n      return createTopology(mongoClient, 'replicaset', _finalOptions, connectCallback);\n    } else if (object.servers.length > 1) {\n      return createTopology(mongoClient, 'mongos', _finalOptions, connectCallback);\n    } else {\n      return createServer(mongoClient, _finalOptions, connectCallback);\n    }\n  });\n\n  function connectCallback(err, topology) {\n    const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;\n\n    if (err && err.message === 'no mongos proxies found in seed list') {\n      if (logger.isWarn()) {\n        logger.warn(warningMessage);\n      } // Return a more specific error message for MongoClient.connect\n\n\n      return callback(new MongoError(warningMessage));\n    }\n\n    if (didRequestAuthentication) {\n      mongoClient.emit('authenticated', null, true);\n    } // Return the error and db instance\n\n\n    callback(err, topology);\n  }\n}\n\nfunction connectWithUrl(mongoClient, url, options, connectCallback) {\n  // Set the topology\n  assignTopology(mongoClient, url); // Add listeners\n\n  addListeners(mongoClient, url); // Propagate the events to the client\n\n  relayEvents(mongoClient, url);\n  let finalOptions = Object.assign({}, options); // If we have a readPreference passed in by the db options, convert it from a string\n\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\n    finalOptions.readPreference = new ReadPreference(options.readPreference || options.read_preference);\n  }\n\n  const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;\n\n  if (isDoingAuth && !finalOptions.credentials) {\n    try {\n      finalOptions.credentials = generateCredentials(mongoClient, finalOptions.user, finalOptions.password, finalOptions);\n    } catch (err) {\n      return connectCallback(err, url);\n    }\n  }\n\n  return url.connect(finalOptions, connectCallback);\n}\n\nfunction createListener(mongoClient, event) {\n  const eventSet = new Set(['all', 'fullsetup', 'open', 'reconnect']);\n  return (v1, v2) => {\n    if (eventSet.has(event)) {\n      return mongoClient.emit(event, mongoClient);\n    }\n\n    mongoClient.emit(event, v1, v2);\n  };\n}\n\nfunction createServer(mongoClient, options, callback) {\n  // Pass in the promise library\n  options.promiseLibrary = mongoClient.s.promiseLibrary; // Set default options\n\n  const servers = translateOptions(options);\n  const server = servers[0]; // Propagate the events to the client\n\n  const collectedEvents = collectEvents(mongoClient, server); // Connect to topology\n\n  server.connect(options, (err, topology) => {\n    if (err) {\n      server.close(true);\n      return callback(err);\n    } // Clear out all the collected event listeners\n\n\n    clearAllEvents(server); // Relay all the events\n\n    relayEvents(mongoClient, server); // Add listeners\n\n    addListeners(mongoClient, server); // Check if we are really speaking to a mongos\n\n    const ismaster = topology.lastIsMaster(); // Set the topology\n\n    assignTopology(mongoClient, topology); // Do we actually have a mongos\n\n    if (ismaster && ismaster.msg === 'isdbgrid') {\n      // Destroy the current connection\n      topology.close(); // Create mongos connection instead\n\n      return createTopology(mongoClient, 'mongos', options, callback);\n    } // Fire all the events\n\n\n    replayEvents(mongoClient, collectedEvents); // Otherwise callback\n\n    callback(err, topology);\n  });\n}\n\nconst DEPRECATED_UNIFIED_EVENTS = new Set(['reconnect', 'reconnectFailed', 'attemptReconnect', 'joined', 'left', 'ping', 'ha', 'all', 'fullsetup', 'open']);\n\nfunction registerDeprecatedEventNotifiers(client) {\n  client.on('newListener', eventName => {\n    if (DEPRECATED_UNIFIED_EVENTS.has(eventName)) {\n      emitDeprecationWarning(`The \\`${eventName}\\` event is no longer supported by the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, 'DeprecationWarning');\n    }\n  });\n}\n\nfunction createTopology(mongoClient, topologyType, options, callback) {\n  // Pass in the promise library\n  options.promiseLibrary = mongoClient.s.promiseLibrary;\n  const translationOptions = {};\n  if (topologyType === 'unified') translationOptions.createServers = false; // Set default options\n\n  const servers = translateOptions(options, translationOptions); // determine CSFLE support\n\n  if (options.autoEncryption != null) {\n    let AutoEncrypter;\n\n    try {\n      require.resolve('mongodb-client-encryption');\n    } catch (err) {\n      callback(new MongoError('Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project'));\n      return;\n    }\n\n    try {\n      let mongodbClientEncryption = require('mongodb-client-encryption');\n\n      if (typeof mongodbClientEncryption.extension !== 'function') {\n        callback(new MongoError('loaded version of `mongodb-client-encryption` does not have property `extension`. Please make sure you are loading the correct version of `mongodb-client-encryption`'));\n      }\n\n      AutoEncrypter = mongodbClientEncryption.extension(require('../../index')).AutoEncrypter;\n    } catch (err) {\n      callback(err);\n      return;\n    }\n\n    const mongoCryptOptions = Object.assign({\n      bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp])\n    }, options.autoEncryption);\n    options.autoEncrypter = new AutoEncrypter(mongoClient, mongoCryptOptions);\n  } // Create the topology\n\n\n  let topology;\n\n  if (topologyType === 'mongos') {\n    topology = new Mongos(servers, options);\n  } else if (topologyType === 'replicaset') {\n    topology = new ReplSet(servers, options);\n  } else if (topologyType === 'unified') {\n    topology = new NativeTopology(options.servers, options);\n    registerDeprecatedEventNotifiers(mongoClient);\n  } // Add listeners\n\n\n  addListeners(mongoClient, topology); // Propagate the events to the client\n\n  relayEvents(mongoClient, topology); // Open the connection\n\n  assignTopology(mongoClient, topology); // initialize CSFLE if requested\n\n  if (options.autoEncrypter) {\n    options.autoEncrypter.init(err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      topology.connect(options, err => {\n        if (err) {\n          topology.close(true);\n          callback(err);\n          return;\n        }\n\n        callback(undefined, topology);\n      });\n    });\n    return;\n  } // otherwise connect normally\n\n\n  topology.connect(options, err => {\n    if (err) {\n      topology.close(true);\n      return callback(err);\n    }\n\n    callback(undefined, topology);\n    return;\n  });\n}\n\nfunction createUnifiedOptions(finalOptions, options) {\n  const childOptions = ['mongos', 'server', 'db', 'replset', 'db_options', 'server_options', 'rs_options', 'mongos_options'];\n  const noMerge = ['readconcern', 'compression', 'autoencryption'];\n\n  for (const name in options) {\n    if (noMerge.indexOf(name.toLowerCase()) !== -1) {\n      finalOptions[name] = options[name];\n    } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {\n      finalOptions = mergeOptions(finalOptions, options[name], false);\n    } else {\n      if (options[name] && typeof options[name] === 'object' && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) {\n        finalOptions = mergeOptions(finalOptions, options[name], true);\n      } else {\n        finalOptions[name] = options[name];\n      }\n    }\n  }\n\n  return finalOptions;\n}\n\nfunction generateCredentials(client, username, password, options) {\n  options = Object.assign({}, options); // the default db to authenticate against is 'self'\n  // if authententicate is called from a retry context, it may be another one, like admin\n\n  const source = options.authSource || options.authdb || options.dbName; // authMechanism\n\n  const authMechanismRaw = options.authMechanism || 'DEFAULT';\n  const authMechanism = authMechanismRaw.toUpperCase();\n  const mechanismProperties = options.authMechanismProperties;\n\n  if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {\n    throw MongoError.create({\n      message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,\n      driver: true\n    });\n  }\n\n  return new MongoCredentials({\n    mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],\n    mechanismProperties,\n    source,\n    username,\n    password\n  });\n}\n\nfunction legacyTransformUrlOptions(object) {\n  return mergeOptions(createUnifiedOptions({}, object), object, false);\n}\n\nfunction mergeOptions(target, source, flatten) {\n  for (const name in source) {\n    if (source[name] && typeof source[name] === 'object' && flatten) {\n      target = mergeOptions(target, source[name], flatten);\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n}\n\nfunction relayEvents(mongoClient, topology) {\n  const serverOrCommandEvents = [// APM\n  'commandStarted', 'commandSucceeded', 'commandFailed', // SDAM\n  'serverOpening', 'serverClosed', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', // Legacy\n  'joined', 'left', 'ping', 'ha'].concat(CMAP_EVENT_NAMES);\n  serverOrCommandEvents.forEach(event => {\n    topology.on(event, (object1, object2) => {\n      mongoClient.emit(event, object1, object2);\n    });\n  });\n} //\n// Replay any events due to single server connection switching to Mongos\n//\n\n\nfunction replayEvents(mongoClient, events) {\n  for (let i = 0; i < events.length; i++) {\n    mongoClient.emit(events[i].event, events[i].object1, events[i].object2);\n  }\n}\n\nfunction transformUrlOptions(_object) {\n  let object = Object.assign({\n    servers: _object.hosts\n  }, _object.options);\n\n  for (let name in object) {\n    const camelCaseName = LEGACY_OPTIONS_MAP[name];\n\n    if (camelCaseName) {\n      object[camelCaseName] = object[name];\n    }\n  }\n\n  const hasUsername = _object.auth && _object.auth.username;\n  const hasAuthMechanism = _object.options && _object.options.authMechanism;\n\n  if (hasUsername || hasAuthMechanism) {\n    object.auth = Object.assign({}, _object.auth);\n\n    if (object.auth.db) {\n      object.authSource = object.authSource || object.auth.db;\n    }\n\n    if (object.auth.username) {\n      object.auth.user = object.auth.username;\n    }\n  }\n\n  if (_object.defaultDatabase) {\n    object.dbName = _object.defaultDatabase;\n  }\n\n  if (object.maxPoolSize) {\n    object.poolSize = object.maxPoolSize;\n  }\n\n  if (object.readConcernLevel) {\n    object.readConcern = new ReadConcern(object.readConcernLevel);\n  }\n\n  if (object.wTimeoutMS) {\n    object.wtimeout = object.wTimeoutMS;\n  }\n\n  if (_object.srvHost) {\n    object.srvHost = _object.srvHost;\n  }\n\n  return object;\n}\n\nfunction translateOptions(options, translationOptions) {\n  translationOptions = Object.assign({}, {\n    createServers: true\n  }, translationOptions); // If we have a readPreference passed in by the db options\n\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\n    options.readPreference = new ReadPreference(options.readPreference || options.read_preference);\n  } // Do we have readPreference tags, add them\n\n\n  if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {\n    options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;\n  } // Do we have maxStalenessSeconds\n\n\n  if (options.maxStalenessSeconds) {\n    options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;\n  } // Set the socket and connection timeouts\n\n\n  if (options.socketTimeoutMS == null) options.socketTimeoutMS = 0;\n  if (options.connectTimeoutMS == null) options.connectTimeoutMS = 10000;\n\n  if (!translationOptions.createServers) {\n    return;\n  } // Create server instances\n\n\n  return options.servers.map(serverObj => {\n    return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options) : new Server(serverObj.host, serverObj.port, options);\n  });\n}\n\nmodule.exports = {\n  validOptions,\n  connect\n};","map":null,"metadata":{},"sourceType":"script"}