{"ast":null,"code":"'use strict';\n\nconst Duplex = require('stream').Duplex;\n\nconst BufferList = require('bl');\n\nconst MongoParseError = require('../core/error').MongoParseError;\n\nconst decompress = require('../core/wireprotocol/compression').decompress;\n\nconst Response = require('../core/connection/commands').Response;\n\nconst BinMsg = require('../core/connection/msg').BinMsg;\n\nconst MongoError = require('../core/error').MongoError;\n\nconst OP_COMPRESSED = require('../core/wireprotocol/shared').opcodes.OP_COMPRESSED;\n\nconst OP_MSG = require('../core/wireprotocol/shared').opcodes.OP_MSG;\n\nconst MESSAGE_HEADER_SIZE = require('../core/wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nconst COMPRESSION_DETAILS_SIZE = require('../core/wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\n\nconst opcodes = require('../core/wireprotocol/shared').opcodes;\n\nconst compress = require('../core/wireprotocol/compression').compress;\n\nconst compressorIDs = require('../core/wireprotocol/compression').compressorIDs;\n\nconst uncompressibleCommands = require('../core/wireprotocol/compression').uncompressibleCommands;\n\nconst Msg = require('../core/connection/msg').Msg;\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\nconst kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n */\n\nclass MessageStream extends Duplex {\n  constructor(options) {\n    options = options || {};\n    super(options);\n    this.bson = options.bson;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new BufferList();\n  }\n\n  _write(chunk, _, callback) {\n    const buffer = this[kBuffer];\n    buffer.append(chunk);\n    processIncomingData(this, callback);\n  }\n\n  _read()\n  /* size */\n  {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;\n\n    if (!shouldCompress || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    } // otherwise, compress the message\n\n\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n    compress({\n      options: operationDescription\n    }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err) {\n        operationDescription.cb(err, null);\n        return;\n      } // Create the msgHeader of OP_COMPRESSED\n\n\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n      // Create the compression details of OP_COMPRESSED\n\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n      compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n\n} // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\n\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  const sizeOfMessage = buffer.readInt32LE(0);\n\n  if (sizeOfMessage < 0) {\n    callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  const message = buffer.slice(0, sizeOfMessage);\n  buffer.consume(sizeOfMessage);\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  const responseOptions = stream.responseOptions;\n\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9); // recalculate based on wrapped opcode\n\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}\n\nmodule.exports = MessageStream;","map":null,"metadata":{},"sourceType":"script"}