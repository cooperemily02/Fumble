{"ast":null,"code":"'use strict';\n\nconst Query = require('../connection/commands').Query;\n\nconst Msg = require('../connection/msg').Msg;\n\nconst MongoError = require('../error').MongoError;\n\nconst getReadPreference = require('./shared').getReadPreference;\n\nconst isSharded = require('./shared').isSharded;\n\nconst databaseNamespace = require('./shared').databaseNamespace;\n\nconst isTransactionCommand = require('../transactions').isTransactionCommand;\n\nconst applySession = require('../sessions').applySession;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst maxWireVersion = require('../utils').maxWireVersion;\n\nfunction isClientEncryptionEnabled(server) {\n  const wireVersion = maxWireVersion(server);\n  return wireVersion && server.autoEncrypter;\n}\n\nfunction command(server, ns, cmd, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n\n  if (cmd == null) {\n    return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));\n  }\n\n  if (!isClientEncryptionEnabled(server)) {\n    _command(server, ns, cmd, options, callback);\n\n    return;\n  }\n\n  const wireVersion = maxWireVersion(server);\n\n  if (typeof wireVersion !== 'number' || wireVersion < 8) {\n    callback(new MongoError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n    return;\n  }\n\n  _cryptCommand(server, ns, cmd, options, callback);\n}\n\nfunction _command(server, ns, cmd, options, callback) {\n  const bson = server.s.bson;\n  const pool = server.s.pool;\n  const readPreference = getReadPreference(cmd, options);\n  const shouldUseOpMsg = supportsOpMsg(server);\n  const session = options.session;\n  let clusterTime = server.clusterTime;\n  let finalCmd = Object.assign({}, cmd);\n\n  if (hasSessionSupport(server) && session) {\n    if (session.clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n      clusterTime = session.clusterTime;\n    }\n\n    const err = applySession(session, finalCmd, options);\n\n    if (err) {\n      return callback(err);\n    }\n  } // if we have a known cluster time, gossip it\n\n\n  if (clusterTime) {\n    finalCmd.$clusterTime = clusterTime;\n  }\n\n  if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n    finalCmd = {\n      $query: finalCmd,\n      $readPreference: readPreference.toJSON()\n    };\n  }\n\n  const commandOptions = Object.assign({\n    command: true,\n    numberToSkip: 0,\n    numberToReturn: -1,\n    checkKeys: false\n  }, options); // This value is not overridable\n\n  commandOptions.slaveOk = readPreference.slaveOk();\n  const cmdNs = `${databaseNamespace(ns)}.$cmd`;\n  const message = shouldUseOpMsg ? new Msg(bson, cmdNs, finalCmd, commandOptions) : new Query(bson, cmdNs, finalCmd, commandOptions);\n  const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));\n  const commandResponseHandler = inTransaction ? function (err) {\n    // We need to add a TransientTransactionError errorLabel, as stated in the transaction spec.\n    if (err && err instanceof MongoNetworkError && !err.hasErrorLabel('TransientTransactionError')) {\n      err.addErrorLabel('TransientTransactionError');\n    }\n\n    if (!cmd.commitTransaction && err && err instanceof MongoError && err.hasErrorLabel('TransientTransactionError')) {\n      session.transaction.unpinServer();\n    }\n\n    return callback.apply(null, arguments);\n  } : callback;\n\n  try {\n    pool.write(message, commandOptions, commandResponseHandler);\n  } catch (err) {\n    commandResponseHandler(err);\n  }\n}\n\nfunction hasSessionSupport(topology) {\n  if (topology == null) return false;\n\n  if (topology.description) {\n    return topology.description.maxWireVersion >= 6;\n  }\n\n  return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;\n}\n\nfunction supportsOpMsg(topologyOrServer) {\n  const description = topologyOrServer.ismaster ? topologyOrServer.ismaster : topologyOrServer.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;\n}\n\nfunction _cryptCommand(server, ns, cmd, options, callback) {\n  const autoEncrypter = server.autoEncrypter;\n\n  function commandResponseHandler(err, response) {\n    if (err || response == null) {\n      callback(err, response);\n      return;\n    }\n\n    autoEncrypter.decrypt(response.result, options, (err, decrypted) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      response.result = decrypted;\n      response.message.documents = [decrypted];\n      callback(null, response);\n    });\n  }\n\n  autoEncrypter.encrypt(ns, cmd, options, (err, encrypted) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    _command(server, ns, encrypted, options, commandResponseHandler);\n  });\n}\n\nmodule.exports = command;","map":null,"metadata":{},"sourceType":"script"}