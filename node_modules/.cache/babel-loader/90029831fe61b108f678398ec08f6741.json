{"ast":null,"code":"/* global WebKitCSSMatrix */\nconst React = require('react');\n\nconst sleep = require('p-sleep');\n\nconst settings = {\n  snapBackDuration: 300,\n  maxTilt: 5,\n  bouncePower: 0.2,\n  swipeThreshold: 300 // px/s\n\n};\n\nconst getElementSize = element => {\n  const elementStyles = window.getComputedStyle(element);\n  const widthString = elementStyles.getPropertyValue('width');\n  const width = Number(widthString.split('px')[0]);\n  const heightString = elementStyles.getPropertyValue('height');\n  const height = Number(heightString.split('px')[0]);\n  return {\n    x: width,\n    y: height\n  };\n};\n\nconst pythagoras = (x, y) => {\n  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n};\n\nconst animateOut = async (element, speed, easeIn = false) => {\n  const startPos = getTranslate(element);\n  const bodySize = getElementSize(document.body);\n  const diagonal = pythagoras(bodySize.x, bodySize.y);\n  const velocity = pythagoras(speed.x, speed.y);\n  const time = diagonal / velocity;\n  const multiplier = diagonal / velocity;\n  const translateString = translationString(speed.x * multiplier + startPos.x, -speed.y * multiplier + startPos.y);\n  let rotateString = '';\n  const rotationPower = 200;\n\n  if (easeIn) {\n    element.style.transition = 'ease ' + time + 's';\n  } else {\n    element.style.transition = 'ease-out ' + time + 's';\n  }\n\n  if (getRotation(element) === 0) {\n    rotateString = rotationString((Math.random() - 0.5) * rotationPower);\n  } else if (getRotation(element) > 0) {\n    rotateString = rotationString(Math.random() * rotationPower / 2 + getRotation(element));\n  } else {\n    rotateString = rotationString((Math.random() - 1) * rotationPower / 2 + getRotation(element));\n  }\n\n  element.style.transform = translateString + rotateString;\n  await sleep(time * 1000);\n};\n\nconst animateBack = element => {\n  element.style.transition = settings.snapBackDuration + 'ms';\n  const startingPoint = getTranslate(element);\n  const translation = translationString(startingPoint.x * -settings.bouncePower, startingPoint.y * -settings.bouncePower);\n  const rotation = rotationString(getRotation(element) * -settings.bouncePower);\n  element.style.transform = translation + rotation;\n  setTimeout(() => {\n    element.style.transform = 'none';\n  }, settings.snapBackDuration * 0.75);\n  setTimeout(() => {\n    element.style.transition = '10ms';\n  }, settings.snapBackDuration);\n};\n\nconst getSwipeDirection = speed => {\n  if (Math.abs(speed.x) > Math.abs(speed.y)) {\n    return speed.x > 0 ? 'right' : 'left';\n  } else {\n    return speed.y > 0 ? 'up' : 'down';\n  }\n};\n\nconst calcSpeed = (oldLocation, newLocation) => {\n  const dx = newLocation.x - oldLocation.x;\n  const dy = oldLocation.y - newLocation.y;\n  const dt = (newLocation.time - oldLocation.time) / 1000;\n  return {\n    x: dx / dt,\n    y: dy / dt\n  };\n};\n\nconst translationString = (x, y) => {\n  const translation = 'translate(' + x + 'px, ' + y + 'px)';\n  return translation;\n};\n\nconst rotationString = rot => {\n  const rotation = 'rotate(' + rot + 'deg)';\n  return rotation;\n};\n\nconst getTranslate = element => {\n  const style = window.getComputedStyle(element);\n  const matrix = new WebKitCSSMatrix(style.webkitTransform);\n  const ans = {\n    x: matrix.m41,\n    y: matrix.m42\n  };\n  return ans;\n};\n\nconst getRotation = element => {\n  const style = window.getComputedStyle(element);\n  const matrix = new WebKitCSSMatrix(style.webkitTransform);\n  const ans = -Math.asin(matrix.m21) / (2 * Math.PI) * 360;\n  return ans;\n};\n\nconst dragableTouchmove = (coordinates, element, offset, lastLocation) => {\n  const pos = {\n    x: coordinates.x + offset.x,\n    y: coordinates.y + offset.y\n  };\n  const newLocation = {\n    x: pos.x,\n    y: pos.y,\n    time: new Date().getTime()\n  };\n  const translation = translationString(pos.x, pos.y);\n  const rotCalc = calcSpeed(lastLocation, newLocation).x / 1000;\n  const rotation = rotationString(rotCalc * settings.maxTilt);\n  element.style.transform = translation + rotation;\n  return newLocation;\n};\n\nconst touchCoordinatesFromEvent = e => {\n  const touchLocation = e.targetTouches[0];\n  return {\n    x: touchLocation.clientX,\n    y: touchLocation.clientY\n  };\n};\n\nconst mouseCoordinatesFromEvent = e => {\n  return {\n    x: e.clientX,\n    y: e.clientY\n  };\n};\n\nconst TinderCard = React.forwardRef(({\n  flickOnSwipe = true,\n  children,\n  onSwipe,\n  onCardLeftScreen,\n  className,\n  preventSwipe = []\n}, ref) => {\n  const swipeAlreadyReleased = React.useRef(false);\n  const element = React.useRef();\n  React.useImperativeHandle(ref, () => ({\n    async swipe(dir = 'right') {\n      if (onSwipe) onSwipe(dir);\n      const power = 1000;\n      const disturbance = (Math.random() - 0.5) * 100;\n\n      if (dir === 'right') {\n        await animateOut(element.current, {\n          x: power,\n          y: disturbance\n        }, true);\n      } else if (dir === 'left') {\n        await animateOut(element.current, {\n          x: -power,\n          y: disturbance\n        }, true);\n      } else if (dir === 'up') {\n        await animateOut(element.current, {\n          x: disturbance,\n          y: power\n        }, true);\n      } else if (dir === 'down') {\n        await animateOut(element.current, {\n          x: disturbance,\n          y: -power\n        }, true);\n      }\n\n      element.current.style.display = 'none';\n      if (onCardLeftScreen) onCardLeftScreen(dir);\n    }\n\n  }));\n  const handleSwipeReleased = React.useCallback(async (element, speed) => {\n    if (swipeAlreadyReleased.current) {\n      return;\n    }\n\n    swipeAlreadyReleased.current = true; // Check if this is a swipe\n\n    if (Math.abs(speed.x) > settings.swipeThreshold || Math.abs(speed.y) > settings.swipeThreshold) {\n      const dir = getSwipeDirection(speed);\n      if (onSwipe) onSwipe(dir);\n\n      if (flickOnSwipe) {\n        if (!preventSwipe.includes(dir)) {\n          await animateOut(element, speed);\n          element.style.display = 'none';\n          if (onCardLeftScreen) onCardLeftScreen(dir);\n          return;\n        }\n      }\n    } // Card was not flicked away, animate back to start\n\n\n    animateBack(element);\n  }, [swipeAlreadyReleased, flickOnSwipe, onSwipe, onCardLeftScreen, preventSwipe]);\n  const handleSwipeStart = React.useCallback(() => {\n    swipeAlreadyReleased.current = false;\n  }, [swipeAlreadyReleased]);\n  React.useLayoutEffect(() => {\n    let offset = {\n      x: null,\n      y: null\n    };\n    let speed = {\n      x: 0,\n      y: 0\n    };\n    let lastLocation = {\n      x: 0,\n      y: 0,\n      time: new Date().getTime()\n    };\n    let mouseIsClicked = false;\n    element.current.addEventListener('touchstart', ev => {\n      ev.preventDefault();\n      handleSwipeStart();\n      offset = {\n        x: -touchCoordinatesFromEvent(ev).x,\n        y: -touchCoordinatesFromEvent(ev).y\n      };\n    });\n    element.current.addEventListener('mousedown', ev => {\n      ev.preventDefault();\n      mouseIsClicked = true;\n      handleSwipeStart();\n      offset = {\n        x: -mouseCoordinatesFromEvent(ev).x,\n        y: -mouseCoordinatesFromEvent(ev).y\n      };\n    });\n    element.current.addEventListener('touchmove', ev => {\n      ev.preventDefault();\n      const newLocation = dragableTouchmove(touchCoordinatesFromEvent(ev), element.current, offset, lastLocation);\n      speed = calcSpeed(lastLocation, newLocation);\n      lastLocation = newLocation;\n    });\n    element.current.addEventListener('mousemove', ev => {\n      ev.preventDefault();\n\n      if (mouseIsClicked) {\n        const newLocation = dragableTouchmove(mouseCoordinatesFromEvent(ev), element.current, offset, lastLocation);\n        speed = calcSpeed(lastLocation, newLocation);\n        lastLocation = newLocation;\n      }\n    });\n    element.current.addEventListener('touchend', ev => {\n      ev.preventDefault();\n      handleSwipeReleased(element.current, speed);\n    });\n    element.current.addEventListener('mouseup', ev => {\n      if (mouseIsClicked) {\n        ev.preventDefault();\n        mouseIsClicked = false;\n        handleSwipeReleased(element.current, speed);\n      }\n    });\n    element.current.addEventListener('mouseleave', ev => {\n      if (mouseIsClicked) {\n        ev.preventDefault();\n        mouseIsClicked = false;\n        handleSwipeReleased(element.current, speed);\n      }\n    });\n  }, []);\n  return React.createElement('div', {\n    ref: element,\n    className\n  }, children);\n});\nmodule.exports = TinderCard;","map":null,"metadata":{},"sourceType":"script"}