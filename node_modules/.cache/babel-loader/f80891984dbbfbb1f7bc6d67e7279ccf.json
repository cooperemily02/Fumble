{"ast":null,"code":"'use strict';\n\nconst Aspect = require('./operation').Aspect;\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst debugOptions = require('../utils').debugOptions;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('../core').MongoError;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\n\nconst debugFields = ['authSource', 'w', 'wtimeout', 'j', 'native_parser', 'forceServerObjectId', 'serializeFunctions', 'raw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bufferMaxEntries', 'numberOfRetries', 'retryMiliSeconds', 'readPreference', 'pkFactory', 'parentDb', 'promiseLibrary', 'noListener'];\n\nclass CommandOperation extends OperationBase {\n  constructor(db, options, collection, command) {\n    super(options);\n\n    if (!this.hasAspect(Aspect.WRITE_OPERATION)) {\n      if (collection != null) {\n        this.options.readPreference = ReadPreference.resolve(collection, options);\n      } else {\n        this.options.readPreference = ReadPreference.resolve(db, options);\n      }\n    } else {\n      if (collection != null) {\n        applyWriteConcern(this.options, {\n          db,\n          coll: collection\n        }, this.options);\n      } else {\n        applyWriteConcern(this.options, {\n          db\n        }, this.options);\n      }\n\n      this.options.readPreference = ReadPreference.primary;\n    }\n\n    this.db = db;\n\n    if (command != null) {\n      this.command = command;\n    }\n\n    if (collection != null) {\n      this.collection = collection;\n    }\n  }\n\n  _buildCommand() {\n    if (this.command != null) {\n      return this.command;\n    }\n  }\n\n  execute(callback) {\n    const db = this.db;\n    const options = Object.assign({}, this.options); // Did the user destroy the topology\n\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    let command;\n\n    try {\n      command = this._buildCommand();\n    } catch (e) {\n      return callback(e);\n    } // Get the db name we are executing against\n\n\n    const dbName = options.dbName || options.authdb || db.databaseName; // Convert the readPreference if its not a write\n\n    if (this.hasAspect(Aspect.WRITE_OPERATION)) {\n      if (options.writeConcern && (!options.session || !options.session.inTransaction())) {\n        command.writeConcern = options.writeConcern;\n      }\n    } // Debug information\n\n\n    if (db.s.logger.isDebug()) {\n      db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options))}]`);\n    }\n\n    const namespace = this.namespace != null ? this.namespace : new MongoDBNamespace(dbName, '$cmd'); // Execute command\n\n    db.s.topology.command(namespace, command, options, (err, result) => {\n      if (err) return handleCallback(callback, err);\n      if (options.full) return handleCallback(callback, null, result);\n      handleCallback(callback, null, result.result);\n    });\n  }\n\n}\n\nmodule.exports = CommandOperation;","map":null,"metadata":{},"sourceType":"script"}