{"ast":null,"code":"'use strict';\n\nvar f = require('util').format,\n    MongoError = require('../error').MongoError; // Filters for classes\n\n\nvar classFilters = {};\nvar filteredClasses = {};\nvar level = null; // Save the process id\n\nvar pid = process.pid; // current logger\n\nvar currentLogger = null;\n/**\n * @callback Logger~loggerCallback\n * @param {string} msg message being logged\n * @param {object} state an object containing more metadata about the logging message\n */\n\n/**\n * Creates a new Logger instance\n * @class\n * @param {string} className The Class name associated with the logging instance\n * @param {object} [options=null] Optional settings.\n * @param {Logger~loggerCallback} [options.logger=null] Custom logger function;\n * @param {string} [options.loggerLevel=error] Override default global log level.\n */\n\nvar Logger = function (className, options) {\n  if (!(this instanceof Logger)) return new Logger(className, options);\n  options = options || {}; // Current reference\n\n  this.className = className; // Current logger\n\n  if (options.logger) {\n    currentLogger = options.logger;\n  } else if (currentLogger == null) {\n    currentLogger = console.log;\n  } // Set level of logging, default is error\n\n\n  if (options.loggerLevel) {\n    level = options.loggerLevel || 'error';\n  } // Add all class names\n\n\n  if (filteredClasses[this.className] == null) classFilters[this.className] = true;\n};\n/**\n * Log a message at the debug level\n * @method\n * @param {string} message The message to log\n * @param {object} object additional meta data to log\n * @return {null}\n */\n\n\nLogger.prototype.debug = function (message, object) {\n  if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {\n    var dateTime = new Date().getTime();\n    var msg = f('[%s-%s:%s] %s %s', 'DEBUG', this.className, pid, dateTime, message);\n    var state = {\n      type: 'debug',\n      message: message,\n      className: this.className,\n      pid: pid,\n      date: dateTime\n    };\n    if (object) state.meta = object;\n    currentLogger(msg, state);\n  }\n};\n/**\n * Log a message at the warn level\n * @method\n * @param {string} message The message to log\n * @param {object} object additional meta data to log\n * @return {null}\n */\n\n\nLogger.prototype.warn = function (message, object) {\n  if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {\n    var dateTime = new Date().getTime();\n    var msg = f('[%s-%s:%s] %s %s', 'WARN', this.className, pid, dateTime, message);\n    var state = {\n      type: 'warn',\n      message: message,\n      className: this.className,\n      pid: pid,\n      date: dateTime\n    };\n    if (object) state.meta = object;\n    currentLogger(msg, state);\n  }\n},\n/**\n * Log a message at the info level\n * @method\n * @param {string} message The message to log\n * @param {object} object additional meta data to log\n * @return {null}\n */\nLogger.prototype.info = function (message, object) {\n  if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {\n    var dateTime = new Date().getTime();\n    var msg = f('[%s-%s:%s] %s %s', 'INFO', this.className, pid, dateTime, message);\n    var state = {\n      type: 'info',\n      message: message,\n      className: this.className,\n      pid: pid,\n      date: dateTime\n    };\n    if (object) state.meta = object;\n    currentLogger(msg, state);\n  }\n},\n/**\n * Log a message at the error level\n * @method\n * @param {string} message The message to log\n * @param {object} object additional meta data to log\n * @return {null}\n */\nLogger.prototype.error = function (message, object) {\n  if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {\n    var dateTime = new Date().getTime();\n    var msg = f('[%s-%s:%s] %s %s', 'ERROR', this.className, pid, dateTime, message);\n    var state = {\n      type: 'error',\n      message: message,\n      className: this.className,\n      pid: pid,\n      date: dateTime\n    };\n    if (object) state.meta = object;\n    currentLogger(msg, state);\n  }\n},\n/**\n * Is the logger set at info level\n * @method\n * @return {boolean}\n */\nLogger.prototype.isInfo = function () {\n  return level === 'info' || level === 'debug';\n},\n/**\n * Is the logger set at error level\n * @method\n * @return {boolean}\n */\nLogger.prototype.isError = function () {\n  return level === 'error' || level === 'info' || level === 'debug';\n},\n/**\n * Is the logger set at error level\n * @method\n * @return {boolean}\n */\nLogger.prototype.isWarn = function () {\n  return level === 'error' || level === 'warn' || level === 'info' || level === 'debug';\n},\n/**\n * Is the logger set at debug level\n * @method\n * @return {boolean}\n */\nLogger.prototype.isDebug = function () {\n  return level === 'debug';\n};\n/**\n * Resets the logger to default settings, error and no filtered classes\n * @method\n * @return {null}\n */\n\nLogger.reset = function () {\n  level = 'error';\n  filteredClasses = {};\n};\n/**\n * Get the current logger function\n * @method\n * @return {Logger~loggerCallback}\n */\n\n\nLogger.currentLogger = function () {\n  return currentLogger;\n};\n/**\n * Set the current logger function\n * @method\n * @param {Logger~loggerCallback} logger Logger function.\n * @return {null}\n */\n\n\nLogger.setCurrentLogger = function (logger) {\n  if (typeof logger !== 'function') throw new MongoError('current logger must be a function');\n  currentLogger = logger;\n};\n/**\n * Set what classes to log.\n * @method\n * @param {string} type The type of filter (currently only class)\n * @param {string[]} values The filters to apply\n * @return {null}\n */\n\n\nLogger.filter = function (type, values) {\n  if (type === 'class' && Array.isArray(values)) {\n    filteredClasses = {};\n    values.forEach(function (x) {\n      filteredClasses[x] = true;\n    });\n  }\n};\n/**\n * Set the current log level\n * @method\n * @param {string} level Set current log level (debug, info, error)\n * @return {null}\n */\n\n\nLogger.setLevel = function (_level) {\n  if (_level !== 'info' && _level !== 'error' && _level !== 'debug' && _level !== 'warn') {\n    throw new Error(f('%s is an illegal logging level', _level));\n  }\n\n  level = _level;\n};\n\nmodule.exports = Logger;","map":null,"metadata":{},"sourceType":"script"}