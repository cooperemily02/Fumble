{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.stepProgress = exports.speedPerSecond = exports.speedPerFrame = exports.smooth = exports.radiansToDegrees = exports.pointFromAngleAndDistance = exports.getValueFromProgress = exports.getProgressFromValue = exports.distance = exports.dilate = exports.degreesToRadians = exports.angle = undefined;\n\nvar _utils = require('./utils');\n/*\n  Convert number to x decimal places\n\n  @param [number]\n  @param [number]\n  @return [number]\n*/\n\n\nvar toDecimal = function toDecimal(num) {\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  precision = Math.pow(10, precision);\n  return Math.round(num * precision) / precision;\n};\n\nvar ZERO_POINT = {\n  x: 0,\n  y: 0,\n  z: 0\n};\n\nvar distance1D = function distance1D(a, b) {\n  return Math.abs(a - b);\n};\n/*\n  Angle between points\n\n  Translates the hypothetical line so that the 'from' coordinates\n  are at 0,0\n\n  @param [object]: X and Y coordinates of from point\n  @param [object]: X and Y cordinates of to point\n  @return [radian]: Angle between the two points in radians\n*/\n\n\nvar angle = exports.angle = function angle(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZERO_POINT;\n  return radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\n};\n/*\n  Convert degrees to radians\n\n  @param [number]: Value in degrees\n  @return [number]: Value in radians\n*/\n\n\nvar degreesToRadians = exports.degreesToRadians = function degreesToRadians(degrees) {\n  return degrees * Math.PI / 180;\n};\n/*\n  Dilate\n\n  Change the progression between a and b according to dilation.\n\n  So dilation = 0.5 would change\n\n  a --------- b\n\n  to\n\n  a ---- b\n\n  @param [number]: Previous value\n  @param [number]: Current value\n  @param [number]: Dilate progress by x\n  @return [number]: Previous value plus the dilated difference\n*/\n\n\nvar dilate = exports.dilate = function dilate(a, b, dilation) {\n  return a + (b - a) * dilation;\n};\n/*\n  Distance\n\n  Returns the distance between two n dimensional points.\n\n  @param [object/number]: x and y or just x of point A\n  @param [object/number]: (optional): x and y or just x of point B\n  @return [number]: The distance between the two points\n*/\n\n\nvar distance = exports.distance = function distance(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZERO_POINT; // 1D dimensions\n\n  if ((0, _utils.isNum)(a)) {\n    return distance1D(a, b); // Multi-dimensional\n  } else {\n    var xDelta = distance1D(a.x, b.x);\n    var yDelta = distance1D(a.y, b.y);\n    var zDelta = (0, _utils.isNum)(a.z) ? distance1D(a.z, b.z) : 0;\n    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n  }\n};\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n\n\nvar getProgressFromValue = exports.getProgressFromValue = function getProgressFromValue(from, to, value) {\n  return (value - from) / (to - from);\n};\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (a number from 0-1)\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\n\n\nvar getValueFromProgress = exports.getValueFromProgress = function getValueFromProgress(from, to, progress) {\n  return -progress * from + progress * to + from;\n};\n/*\n  Point from angle and distance\n\n  @param [object]: 2D point of origin\n  @param [number]: Angle from origin\n  @param [number]: Distance from origin\n  @return [object]: Calculated 2D point\n*/\n\n\nvar pointFromAngleAndDistance = exports.pointFromAngleAndDistance = function pointFromAngleAndDistance(origin, angle, distance) {\n  angle = degreesToRadians(angle);\n  return {\n    x: distance * Math.cos(angle) + origin.x,\n    y: distance * Math.sin(angle) + origin.y\n  };\n};\n/*\n  Convert radians to degrees\n\n  @param [number]: Value in radians\n  @return [number]: Value in degrees\n*/\n\n\nvar radiansToDegrees = exports.radiansToDegrees = function radiansToDegrees(radians) {\n  return radians * 180 / Math.PI;\n};\n/*\n  Framerate-independent smoothing\n\n  @param [number]: New value\n  @param [number]: Old value\n  @param [number]: Frame duration\n  @param [number] (optional): Smoothing (0 is none)\n*/\n\n\nvar smooth = exports.smooth = function smooth(newValue, oldValue, duration) {\n  var smoothing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  return toDecimal(oldValue + duration * (newValue - oldValue) / Math.max(smoothing, duration));\n};\n/*\n  Convert x per second to per frame velocity based on fps\n\n  @param [number]: Unit per second\n  @param [number]: Frame duration in ms\n*/\n\n\nvar speedPerFrame = exports.speedPerFrame = function speedPerFrame(xps, frameDuration) {\n  return (0, _utils.isNum)(xps) ? xps / (1000 / frameDuration) : 0;\n};\n/*\n  Convert velocity into velicity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\n\n\nvar speedPerSecond = exports.speedPerSecond = function speedPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1000 / frameDuration) : 0;\n};\n/*\n  Create stepped version of 0-1 progress\n\n  @param [int]: Number of steps\n  @param [number]: Current value\n  @return [number]: Stepped value\n*/\n\n\nvar stepProgress = exports.stepProgress = function stepProgress(steps, progress) {\n  var segment = 1 / (steps - 1);\n  var target = 1 - 1 / steps;\n  var progressOfTarget = Math.min(progress / target, 1);\n  return Math.floor(progressOfTarget / segment) * segment;\n};","map":{"version":3,"sources":["../../src/inc/calc.js"],"names":["toDecimal","precision","Math","num","ZERO_POINT","x","y","z","distance1D","a","angle","b","radiansToDegrees","degreesToRadians","degrees","dilate","distance","xDelta","yDelta","zDelta","getProgressFromValue","value","to","getValueFromProgress","progress","pointFromAngleAndDistance","origin","radians","smooth","smoothing","oldValue","duration","newValue","speedPerFrame","xps","speedPerSecond","frameDuration","velocity","stepProgress","segment","steps","target","progressOfTarget"],"mappings":"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","sourcesContent":["import { isNum } from './utils';\n\n/*\n  Convert number to x decimal places\n\n  @param [number]\n  @param [number]\n  @return [number]\n*/\nconst toDecimal = (num, precision = 2) => {\n  precision = 10 ** precision;\n  return Math.round(num * precision) / precision;\n};\n\nconst ZERO_POINT = {\n  x: 0,\n  y: 0,\n  z: 0\n};\n\nconst distance1D = (a, b) => Math.abs(a - b);\n\n/*\n  Angle between points\n\n  Translates the hypothetical line so that the 'from' coordinates\n  are at 0,0\n\n  @param [object]: X and Y coordinates of from point\n  @param [object]: X and Y cordinates of to point\n  @return [radian]: Angle between the two points in radians\n*/\nexport const angle = (a, b = ZERO_POINT) => radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\n\n/*\n  Convert degrees to radians\n\n  @param [number]: Value in degrees\n  @return [number]: Value in radians\n*/\nexport const degreesToRadians = (degrees) => degrees * Math.PI / 180;\n\n/*\n  Dilate\n\n  Change the progression between a and b according to dilation.\n\n  So dilation = 0.5 would change\n\n  a --------- b\n\n  to\n\n  a ---- b\n\n  @param [number]: Previous value\n  @param [number]: Current value\n  @param [number]: Dilate progress by x\n  @return [number]: Previous value plus the dilated difference\n*/\nexport const dilate = (a, b, dilation) => a + ((b - a) * dilation);\n\n/*\n  Distance\n\n  Returns the distance between two n dimensional points.\n\n  @param [object/number]: x and y or just x of point A\n  @param [object/number]: (optional): x and y or just x of point B\n  @return [number]: The distance between the two points\n*/\nexport const distance = (a, b = ZERO_POINT) => {\n  // 1D dimensions\n  if (isNum(a)) {\n    return distance1D(a, b);\n\n  // Multi-dimensional\n  } else {\n    const xDelta = distance1D(a.x, b.x);\n    const yDelta = distance1D(a.y, b.y);\n    const zDelta = (isNum(a.z)) ? distance1D(a.z, b.z) : 0;\n\n    return Math.sqrt((xDelta ** 2) + (yDelta ** 2) + (zDelta ** 2));\n  }\n};\n\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\nexport const getProgressFromValue = (from, to, value) => (value - from) / (to - from);\n\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (a number from 0-1)\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nexport const getValueFromProgress = (from, to, progress) => (- progress * from) + (progress * to) + from;\n\n/*\n  Point from angle and distance\n\n  @param [object]: 2D point of origin\n  @param [number]: Angle from origin\n  @param [number]: Distance from origin\n  @return [object]: Calculated 2D point\n*/\nexport const pointFromAngleAndDistance = (origin, angle, distance) => {\n  angle = degreesToRadians(angle);\n\n  return {\n    x: distance * Math.cos(angle) + origin.x,\n    y: distance * Math.sin(angle) + origin.y\n  };\n};\n\n/*\n  Convert radians to degrees\n\n  @param [number]: Value in radians\n  @return [number]: Value in degrees\n*/\nexport const radiansToDegrees = (radians) => radians * 180 / Math.PI;\n\n/*\n  Framerate-independent smoothing\n\n  @param [number]: New value\n  @param [number]: Old value\n  @param [number]: Frame duration\n  @param [number] (optional): Smoothing (0 is none)\n*/\nexport const smooth = (newValue, oldValue, duration, smoothing = 0) => toDecimal(oldValue + (duration * (newValue - oldValue) / Math.max(smoothing, duration)));\n\n/*\n  Convert x per second to per frame velocity based on fps\n\n  @param [number]: Unit per second\n  @param [number]: Frame duration in ms\n*/\nexport const speedPerFrame = (xps, frameDuration) => (isNum(xps)) ? xps / (1000 / frameDuration) : 0;\n\n/*\n  Convert velocity into velicity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nexport const speedPerSecond = (velocity, frameDuration) => frameDuration ? velocity * (1000 / frameDuration) : 0;\n\n/*\n  Create stepped version of 0-1 progress\n\n  @param [int]: Number of steps\n  @param [number]: Current value\n  @return [number]: Stepped value\n*/\nexport const stepProgress = (steps, progress) => {\n  const segment = 1 / (steps - 1);\n  const target = 1 - (1 / steps);\n  const progressOfTarget = Math.min(progress / target, 1);\n\n  return Math.floor(progressOfTarget / segment) * segment;\n};\n"]},"metadata":{},"sourceType":"script"}