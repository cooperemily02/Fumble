{"ast":null,"code":"'use strict';\n\nconst GetMore = require('../connection/commands').GetMore;\n\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\n\nconst MongoError = require('../error').MongoError;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst BSON = retrieveBSON();\nconst Long = BSON.Long;\n\nconst collectionNamespace = require('./shared').collectionNamespace;\n\nconst maxWireVersion = require('../utils').maxWireVersion;\n\nconst applyCommonQueryOptions = require('./shared').applyCommonQueryOptions;\n\nconst command = require('./command');\n\nfunction getMore(server, ns, cursorState, batchSize, options, callback) {\n  options = options || {};\n  const wireVersion = maxWireVersion(server);\n\n  function queryCallback(err, result) {\n    if (err) return callback(err);\n    const response = result.message; // If we have a timed out query or a cursor that was killed\n\n    if (response.cursorNotFound) {\n      return callback(new MongoNetworkError('cursor killed or timed out'), null);\n    }\n\n    if (wireVersion < 4) {\n      const cursorId = typeof response.cursorId === 'number' ? Long.fromNumber(response.cursorId) : response.cursorId;\n      cursorState.documents = response.documents;\n      cursorState.cursorId = cursorId;\n      callback(null, null, response.connection);\n      return;\n    } // We have an error detected\n\n\n    if (response.documents[0].ok === 0) {\n      return callback(new MongoError(response.documents[0]));\n    } // Ensure we have a Long valid cursor id\n\n\n    const cursorId = typeof response.documents[0].cursor.id === 'number' ? Long.fromNumber(response.documents[0].cursor.id) : response.documents[0].cursor.id;\n    cursorState.documents = response.documents[0].cursor.nextBatch;\n    cursorState.cursorId = cursorId;\n    callback(null, response.documents[0], response.connection);\n  }\n\n  if (wireVersion < 4) {\n    const bson = server.s.bson;\n    const getMoreOp = new GetMore(bson, ns, cursorState.cursorId, {\n      numberToReturn: batchSize\n    });\n    const queryOptions = applyCommonQueryOptions({}, cursorState);\n    server.s.pool.write(getMoreOp, queryOptions, queryCallback);\n    return;\n  }\n\n  const cursorId = cursorState.cursorId instanceof Long ? cursorState.cursorId : Long.fromNumber(cursorState.cursorId);\n  const getMoreCmd = {\n    getMore: cursorId,\n    collection: collectionNamespace(ns),\n    batchSize: Math.abs(batchSize)\n  };\n\n  if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === 'number') {\n    getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;\n  }\n\n  const commandOptions = Object.assign({\n    returnFieldSelector: null,\n    documentsReturnedIn: 'nextBatch'\n  }, options);\n\n  if (cursorState.session) {\n    commandOptions.session = cursorState.session;\n  }\n\n  command(server, ns, getMoreCmd, commandOptions, queryCallback);\n}\n\nmodule.exports = getMore;","map":null,"metadata":{},"sourceType":"script"}