{"ast":null,"code":"'use strict';\n\nconst common = require('./common');\n\nconst BulkOperationBase = common.BulkOperationBase;\nconst Batch = common.Batch;\nconst bson = common.bson;\n\nconst utils = require('../utils');\n\nconst toError = utils.toError;\n/**\n * Add to internal list of Operations\n *\n * @ignore\n * @param {UnorderedBulkOperation} bulkOperation\n * @param {number} docType number indicating the document type\n * @param {object} document\n * @return {UnorderedBulkOperation}\n */\n\nfunction addToOperationsList(bulkOperation, docType, document) {\n  // Get the bsonSize\n  const bsonSize = bson.calculateObjectSize(document, {\n    checkKeys: false,\n    // Since we don't know what the user selected for BSON options here,\n    // err on the safe side, and check the size with ignoreUndefined: false.\n    ignoreUndefined: false\n  }); // Throw error if the doc is bigger than the max BSON size\n\n  if (bsonSize >= bulkOperation.s.maxBsonObjectSize) throw toError('document is larger than the maximum size ' + bulkOperation.s.maxBsonObjectSize); // Holds the current batch\n\n  bulkOperation.s.currentBatch = null; // Get the right type of batch\n\n  if (docType === common.INSERT) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;\n  } else if (docType === common.UPDATE) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;\n  } else if (docType === common.REMOVE) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;\n  }\n\n  const maxKeySize = bulkOperation.s.maxKeySize; // Create a new batch object if we don't have a current one\n\n  if (bulkOperation.s.currentBatch == null) bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex); // Check if we need to create a new batch\n\n  if ( // New batch if we exceed the max batch op size\n  bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,\n  // since we can't sent an empty batch\n  bulkOperation.s.currentBatch.size > 0 && bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch\n  bulkOperation.s.currentBatch.batchType !== docType) {\n    // Save the batch to the execution stack\n    bulkOperation.s.batches.push(bulkOperation.s.currentBatch); // Create a new batch\n\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);\n  } // We have an array of documents\n\n\n  if (Array.isArray(document)) {\n    throw toError('operation passed in cannot be an Array');\n  }\n\n  bulkOperation.s.currentBatch.operations.push(document);\n  bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);\n  bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1; // Save back the current Batch to the right type\n\n  if (docType === common.INSERT) {\n    bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;\n    bulkOperation.s.bulkResult.insertedIds.push({\n      index: bulkOperation.s.bulkResult.insertedIds.length,\n      _id: document._id\n    });\n  } else if (docType === common.UPDATE) {\n    bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;\n  } else if (docType === common.REMOVE) {\n    bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;\n  } // Update current batch size\n\n\n  bulkOperation.s.currentBatch.size += 1;\n  bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize; // Return bulkOperation\n\n  return bulkOperation;\n}\n/**\n * Create a new UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @extends BulkOperationBase\n * @property {number} length Get the number of operations in the bulk.\n * @return {UnorderedBulkOperation} a UnorderedBulkOperation instance.\n */\n\n\nclass UnorderedBulkOperation extends BulkOperationBase {\n  constructor(topology, collection, options) {\n    options = options || {};\n    options = Object.assign(options, {\n      addToOperationsList\n    });\n    super(topology, collection, options, false);\n  }\n\n  handleWriteError(callback, writeResult) {\n    if (this.s.batches.length) {\n      return false;\n    }\n\n    return super.handleWriteError(callback, writeResult);\n  }\n\n}\n/**\n * Returns an unordered batch object\n * @ignore\n */\n\n\nfunction initializeUnorderedBulkOp(topology, collection, options) {\n  return new UnorderedBulkOperation(topology, collection, options);\n}\n\ninitializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;\nmodule.exports = initializeUnorderedBulkOp;\nmodule.exports.Bulk = UnorderedBulkOperation;","map":null,"metadata":{},"sourceType":"script"}