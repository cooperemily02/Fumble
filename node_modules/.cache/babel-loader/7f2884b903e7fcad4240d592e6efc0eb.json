{"ast":null,"code":"'use strict';\n\nconst ReadPreference = require('./read_preference');\n\nconst TopologyType = require('../sdam/common').TopologyType;\n\nconst MongoError = require('../error').MongoError;\n\nconst isRetryableWriteError = require('../error').isRetryableWriteError;\n\nconst maxWireVersion = require('../utils').maxWireVersion;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = 20;\n/**\n * Emit event if it exists\n * @method\n */\n\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n\nfunction createCompressionInfo(options) {\n  if (!options.compression || !options.compression.compressors) {\n    return [];\n  } // Check that all supplied compressors are valid\n\n\n  options.compression.compressors.forEach(function (compressor) {\n    if (compressor !== 'snappy' && compressor !== 'zlib') {\n      throw new Error('compressors must be at least one of snappy or zlib');\n    }\n  });\n  return options.compression.compressors;\n}\n\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\nvar getPreviousDescription = function (self) {\n  if (!self.s.serverDescription) {\n    self.s.serverDescription = {\n      address: self.name,\n      arbiters: [],\n      hosts: [],\n      passives: [],\n      type: 'Unknown'\n    };\n  }\n\n  return self.s.serverDescription;\n};\n\nvar emitServerDescriptionChanged = function (self, description) {\n  if (self.listeners('serverDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('serverDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n\nvar getPreviousTopologyDescription = function (self) {\n  if (!self.s.topologyDescription) {\n    self.s.topologyDescription = {\n      topologyType: 'Unknown',\n      servers: [{\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: 'Unknown'\n      }]\n    };\n  }\n\n  return self.s.topologyDescription;\n};\n\nvar emitTopologyDescriptionChanged = function (self, description) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('topologyDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousTopologyDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n\nvar changedIsMaster = function (self, currentIsmaster, ismaster) {\n  var currentType = getTopologyType(self, currentIsmaster);\n  var newType = getTopologyType(self, ismaster);\n  if (newType !== currentType) return true;\n  return false;\n};\n\nvar getTopologyType = function (self, ismaster) {\n  if (!ismaster) {\n    ismaster = self.ismaster;\n  }\n\n  if (!ismaster) return 'Unknown';\n  if (ismaster.ismaster && ismaster.msg === 'isdbgrid') return 'Mongos';\n  if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';\n  if (ismaster.ismaster) return 'RSPrimary';\n  if (ismaster.secondary) return 'RSSecondary';\n  if (ismaster.arbiterOnly) return 'RSArbiter';\n  return 'Unknown';\n};\n\nvar inquireServerState = function (self) {\n  return function (callback) {\n    if (self.s.state === 'destroyed') return; // Record response time\n\n    var start = new Date().getTime(); // emitSDAMEvent\n\n    emitSDAMEvent(self, 'serverHeartbeatStarted', {\n      connectionId: self.name\n    }); // Attempt to execute ismaster command\n\n    self.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      monitoring: true\n    }, function (err, r) {\n      if (!err) {\n        // Legacy event sender\n        self.emit('ismaster', r, self); // Calculate latencyMS\n\n        var latencyMS = new Date().getTime() - start; // Server heart beat event\n\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: self.name\n        }); // Did the server change\n\n        if (changedIsMaster(self, self.s.ismaster, r.result)) {\n          // Emit server description changed if something listening\n          emitServerDescriptionChanged(self, {\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n          });\n        } // Updat ismaster view\n\n\n        self.s.ismaster = r.result; // Set server response time\n\n        self.s.isMasterLatencyMS = latencyMS;\n      } else {\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: self.name\n        });\n      } // Peforming an ismaster monitoring callback operation\n\n\n      if (typeof callback === 'function') {\n        return callback(err, r);\n      } // Perform another sweep\n\n\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\n    });\n  };\n}; //\n// Clone the options\n\n\nvar cloneOptions = function (options) {\n  var opts = {};\n\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n\n  return opts;\n};\n\nfunction Interval(fn, time) {\n  var timer = false;\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setInterval(fn, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function () {\n    clearInterval(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    return timer !== false;\n  };\n}\n\nfunction Timeout(fn, time) {\n  var timer = false;\n\n  var func = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = false;\n      fn();\n    }\n  };\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setTimeout(func, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function () {\n    clearTimeout(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    return timer !== false;\n  };\n}\n\nfunction diff(previous, current) {\n  // Difference document\n  var diff = {\n    servers: []\n  }; // Previous entry\n\n  if (!previous) {\n    previous = {\n      servers: []\n    };\n  } // Check if we have any previous servers missing in the current ones\n\n\n  for (var i = 0; i < previous.servers.length; i++) {\n    var found = false;\n\n    for (var j = 0; j < current.servers.length; j++) {\n      if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      // Add to the diff\n      diff.servers.push({\n        address: previous.servers[i].address,\n        from: previous.servers[i].type,\n        to: 'Unknown'\n      });\n    }\n  } // Check if there are any severs that don't exist\n\n\n  for (j = 0; j < current.servers.length; j++) {\n    found = false; // Go over all the previous servers\n\n    for (i = 0; i < previous.servers.length; i++) {\n      if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    } // Add the server to the diff\n\n\n    if (!found) {\n      diff.servers.push({\n        address: current.servers[j].address,\n        from: 'Unknown',\n        to: current.servers[j].type\n      });\n    }\n  } // Got through all the servers\n\n\n  for (i = 0; i < previous.servers.length; i++) {\n    var prevServer = previous.servers[i]; // Go through all current servers\n\n    for (j = 0; j < current.servers.length; j++) {\n      var currServer = current.servers[j]; // Matching server\n\n      if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {\n        // We had a change in state\n        if (prevServer.type !== currServer.type) {\n          diff.servers.push({\n            address: prevServer.address,\n            from: prevServer.type,\n            to: currServer.type\n          });\n        }\n      }\n    }\n  } // Return difference\n\n\n  return diff;\n}\n/**\n * Shared function to determine clusterTime for a given topology\n *\n * @param {*} topology\n * @param {*} clusterTime\n */\n\n\nfunction resolveClusterTime(topology, $clusterTime) {\n  if (topology.clusterTime == null) {\n    topology.clusterTime = $clusterTime;\n  } else {\n    if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {\n      topology.clusterTime = $clusterTime;\n    }\n  }\n} // NOTE: this is a temporary move until the topologies can be more formally refactored\n//       to share code.\n\n\nconst SessionMixins = {\n  endSessions: function (sessions, callback) {\n    if (!Array.isArray(sessions)) {\n      sessions = [sessions];\n    } // TODO:\n    //   When connected to a sharded cluster the endSessions command\n    //   can be sent to any mongos. When connected to a replica set the\n    //   endSessions command MUST be sent to the primary if the primary\n    //   is available, otherwise it MUST be sent to any available secondary.\n    //   Is it enough to use: ReadPreference.primaryPreferred ?\n\n\n    this.command('admin.$cmd', {\n      endSessions: sessions\n    }, {\n      readPreference: ReadPreference.primaryPreferred\n    }, () => {\n      // intentionally ignored, per spec\n      if (typeof callback === 'function') callback();\n    });\n  }\n};\n\nfunction topologyType(topology) {\n  if (topology.description) {\n    return topology.description.type;\n  }\n\n  if (topology.type === 'mongos') {\n    return TopologyType.Sharded;\n  } else if (topology.type === 'replset') {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  return TopologyType.Single;\n}\n\nconst RETRYABLE_WIRE_VERSION = 6;\n/**\n * Determines whether the provided topology supports retryable writes\n *\n * @param {Mongos|Replset} topology\n */\n\nconst isRetryableWritesSupported = function (topology) {\n  const maxWireVersion = topology.lastIsMaster().maxWireVersion;\n\n  if (maxWireVersion < RETRYABLE_WIRE_VERSION) {\n    return false;\n  }\n\n  if (!topology.logicalSessionTimeoutMinutes) {\n    return false;\n  }\n\n  if (topologyType(topology) === TopologyType.Single) {\n    return false;\n  }\n\n  return true;\n};\n\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction getMMAPError(err) {\n  if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes('Transaction numbers')) {\n    return err;\n  } // According to the retryable writes spec, we must replace the error message in this case.\n  // We need to replace err.message so the thrown message is correct and we need to replace err.errmsg to meet the spec requirement.\n\n\n  const newErr = new MongoError({\n    message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    originalError: err\n  });\n  return newErr;\n} // NOTE: only used for legacy topology types\n\n\nfunction legacyIsRetryableWriteError(err, topology) {\n  if (!(err instanceof MongoError)) {\n    return false;\n  } // if pre-4.4 server, then add error label if its a retryable write error\n\n\n  if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {\n    err.addErrorLabel('RetryableWriteError');\n  }\n\n  return err.hasErrorLabel('RetryableWriteError');\n}\n\nmodule.exports = {\n  SessionMixins,\n  resolveClusterTime,\n  inquireServerState,\n  getTopologyType,\n  emitServerDescriptionChanged,\n  emitTopologyDescriptionChanged,\n  cloneOptions,\n  createCompressionInfo,\n  clone,\n  diff,\n  Interval,\n  Timeout,\n  isRetryableWritesSupported,\n  getMMAPError,\n  topologyType,\n  legacyIsRetryableWriteError\n};","map":null,"metadata":{},"sourceType":"script"}